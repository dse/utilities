#!/usr/bin/env perl
use warnings;
use strict;

use POSIX qw(dup2);

our $hasPty = 0;
BEGIN {
    $hasPty = eval { require IO::Pty; }
}
our $stdoutPty = $hasPty && -t 1;
our $stderrPty = $hasPty && -t 2;

our @pipe1 = ('sed', 's/^/STDOUT: /');
our @pipe2 = ('sed', 's/^/STDERR: /');


my ($read1, $write1);
if ($stdoutPty) {
    $write1 = IO::Pty->new();
    if (!$write1) {
        die("pty: $!");
    }
    $read1 = $write1->slave();
} else {
    if (!pipe($read1, $write1)) {
        die("pipe: $!");
    }
}

my $pid1 = fork();
if (!defined $pid1) {
    die("fork: $!");
}
if (!$pid1) {
    if ($stdoutPty) {
        $write1->make_slave_controlling_terminal();
    }
    close($write1);
    dup2(fileno($read1), fileno(\*STDIN)); # redirect stdin from the first pipe
    exec(@pipe1);
}

if ($stdoutPty) {
    $write1->close_slave();
} else {
    close($read1);
}

my ($read2, $write2);
if ($stderrPty) {
    $write2 = IO::Pty->new();
    if (!$write2) {
        die("pty: $!");
    }
    $read2 = $write2->slave();
} else {
    if (!pipe($read2, $write2)) {
        die("pipe: $!");
    }
}

my $pid2 = fork();
if (!defined $pid2) {
    die("fork: $!");
}
if (!$pid2) {
    if ($stdoutPty) {
        $write2->make_slave_controlling_terminal();
    }
    close($write2);
    dup2(fileno($read2), fileno(\*STDIN)); # redirect stdin from the second pipe
    dup2(fileno(\*STDERR), fileno(\*STDOUT)); # redirect stdout to stderr
    exec(@pipe2);
}

if ($stderrPty) {
    $write2->close_slave();
} else {
    close($read2);
}

dup2(fileno($write1), fileno(\*STDOUT));  # redirect stdout to the first pipe
dup2(fileno($write2), fileno(\*STDERR));  # redirect stderr to the second pipe
exec(@ARGV);
