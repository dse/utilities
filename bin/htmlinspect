#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;
use utf8;

use open IO => ":locale";

use strictures;
use HTML::TreeBuilder;
use Getopt::Long;
use Data::Dumper;

our $opt_show_attributes;
our $opt_show_first_child;
our $opt_show_last_child;
our @opt_search;
our $opt_fancy;
our $opt_tree;
our $opt_theme = 'blank';
our $opt_carp_test;
our $opt_show_ancestors;
our $opt_no_recurse;

BEGIN {
    if (grep { $_ eq "--carp" } @ARGV) {
        # This does nothing during regular runtime.
        require Carp::Always;
        import Carp::Always;
    }
}

###############################################################################

# gnu_compat disables ":s" options if a value is not supplied.

Getopt::Long::Configure("bundling", "gnu_compat", "no_ignore_case");
Getopt::Long::GetOptions(
    "s|search=s"                   => \@opt_search,
    "A|ancestors|show-ancestors"   => \$opt_show_ancestors,
    "R|no-recurse"                 => \$opt_no_recurse,
    "f|fancy"                      => \$opt_fancy,
    "a|attributes|show-attributes" => \$opt_show_attributes,
    "first-child|show-first-child" => \$opt_show_first_child,
    "last-child|show-last-child"   => \$opt_show_last_child,
    "t|tree"                       => \$opt_tree,
    "T|theme|tree-theme=s" => sub {
        my $value = $_[1];
        if ($value ne "blank" && $value ne "ascii" && $value ne "light" && $value ne "heavy") {
            die("Invalid tree theme: $value\n");
        }
        $opt_tree = 1;
    },
    "blank" => sub { $opt_theme = "blank"; $opt_tree = 1; },
    "ascii" => sub { $opt_theme = "ascii"; $opt_tree = 1; },
    "light" => sub { $opt_theme = "light"; $opt_tree = 1; },
    "heavy" => sub { $opt_theme = "heavy"; $opt_tree = 1; },
    "carp" => sub { },          # does nothing here, but see above
    "carp-test" => \$opt_carp_test,
    "h|help" => sub { usage(); exit 0; }
) or die("Type '$0 --help' for help.\n");

sub usage { print <<"END"; }
usage:
  htmlinspect [<option> ...] [<file> ...]
options:
  -h, --help
  -a, --[show-]attributes
  -s, --search='<search>'       search by CSS selector
  -R, --no-recurse
  -A, --[show-]ancestors        only when searching
  -f, --fancy
      --[show-]first-child
      --[show-]last-child
  -t, --tree
  -T, --tree-theme=<theme>      blank, ascii, light, heavy
      --blank
      --ascii
      --light
      --heavy
      --carp                    show stack traces
END

###############################################################################

sub ffff { gggg(); }
sub gggg { hhhh(); }
sub hhhh { iiii(); }
if ($opt_carp_test) {
    ffff();
}

local $/ = undef;
while (<>) {
    my $inspector = My::HTML::Inspector->new();
    $inspector->show_ancestors($opt_show_ancestors);
    $inspector->show_attributes($opt_show_attributes);
    $inspector->show_first_child($opt_show_first_child);
    $inspector->show_last_child($opt_show_last_child);
    $inspector->tree($opt_tree);
    $inspector->theme($opt_theme);
    $inspector->fancy($opt_fancy);
    $inspector->no_recurse($opt_no_recurse);

    my $tree = HTML::TreeBuilder::XPath->new();
    $tree->parse($_);
    $tree->eof();
    if (scalar @opt_search) {
        foreach my $search (@opt_search) {
            my @results = $inspector->search($tree, $search);
            foreach my $result (@results) {
                $inspector->inspect($result, $ARGV);
            }
        }
    } else {
        $inspector->inspect($tree, $ARGV);
    }
}

package My::HTML::Inspector {
    use Class::Tiny qw(show_ancestors
                       show_first_child
                       show_last_child
                       show_attributes
                       no_recurse
                       tree
                       theme
                       fancy);

    INIT {
        eval 'use HTML::Selector::XPath 0.20 qw(selector_to_xpath);';
        die $@ if $@;
        eval 'use HTML::TreeBuilder::XPath;';
        die $@ if $@;
    }

    our $BOX_DRAWING;
    BEGIN {
        $BOX_DRAWING = {
            light => {
                last            => "└── ",
                not_last        => "├── ",
                parent_last     => "    ",
                parent_not_last => "│   ",
            },
            heavy => {
                last            => "┗━━ ",
                not_last        => "┣━━ ",
                parent_last     => "    ",
                parent_not_last => "┃   ",
            },
            ascii => {
                last            => "`-- ",
                not_last        => "|-- ",
                parent_last     => "    ",
                parent_not_last => "|   ",
            },
            blank => {
                last            => "    ",
                not_last        => "    ",
                parent_last     => "    ",
                parent_not_last => "    ",
            },
        };
    }

    our %filename_printed;

    sub inspect {
        my ($self, $element, $filename, %args) = @_;
        if (!ref $element) {
            return;
        }

        my $element_string = $self->element_string($element);

        my $index     = $args{index};
        my $nchildren = $args{nchildren};
        my $level     = $args{level} // 0;
        my $parents   = $args{parents} // [];
        my $prefix    = $args{prefix} // "";

        my @parents = @$parents;
        my $parents_string = join("", map { "$_ " } @$parents);

        if ($self->fancy) {
            if (!$filename_printed{$filename}) {
                print "$filename:\n";
                $filename_printed{$filename} = 1;
            }
            print " " x 4;
        } else {
            print "$filename: ";
        }

        my $newprefix;
        if ($self->tree) {
            if ($self->theme ne "blank") {
                my $drawing;
                if ($level) {
                    $drawing = ($index == $nchildren - 1) ? $BOX_DRAWING->{$self->theme}->{last} : $BOX_DRAWING->{$self->theme}->{not_last};
                } else {
                    $drawing = "";
                }
                print($prefix, $drawing);
                $newprefix = $prefix;
                if ($level) {
                    $newprefix .= (($index == $nchildren - 1) ? $BOX_DRAWING->{$self->theme}->{parent_last} : $BOX_DRAWING->{$self->theme}->{parent_not_last});
                }
            } else {
                print(" " x (4 * $level));
            }
        } else {
            print($parents_string);
        }

        if ($level == 0 && $self->show_ancestors) {
            my $ancestors = "";
            for (my $parent = $element->parent;
                 $parent;
                 $parent = $parent->parent) {
                $ancestors = $self->element_string($parent) . " " . $ancestors;
            }
            print($ancestors);
        }

        print($element_string, "\n");

        if (!$self->no_recurse) {
            my @children = grep { ref $_ } $element->content_list();
            my $index = 0;
            my $nchildren = scalar @children;
            my %args;
            if ($self->tree && $self->theme ne "blank") {
                $args{prefix} = $newprefix;
            }
            foreach my $child (@children) {
                $self->inspect($child,
                               $filename,
                               %args,
                               parents => [@parents, $element_string],
                               index => $index,
                               nchildren => $nchildren,
                               level => $level + 1);
                $index += 1;
            }
        }
    }

    sub element_string {
        my ($self, $element) = @_;
        my $tagname = $element->tag;

        my $result = $tagname;

        my $class = $element->attr('class');
        my @class = defined $class ? split(' ', $class) : ();
        foreach my $class (@class) {
            $result .= "." . $class;
        }

        my $id = $element->attr('id');
        if (defined $id) {
            $result .= "#" . $id;
        }

        if ($self->show_attributes) {
            my @attr_names = $element->all_external_attr_names;
            @attr_names = sort { lc($a) cmp lc($b) } grep { $_ ne "class" && $_ ne "id" && $_ ne "/" } @attr_names;
            foreach my $attr_name (@attr_names) {
                $result .= sprintf("[%s]", $attr_name);
            }
        }

        my @left  = grep { ref $_ } $element->left;
        my @right = grep { ref $_ } $element->right;
        my $is_first_child = !scalar @left;
        my $is_last_child  = !scalar @right;

        if ($self->show_first_child && $is_first_child) {
            $result .= ":first-child";
        }
        if ($self->show_last_child && $is_last_child) {
            $result .= ":last-child";
        }

        return $result;
    }

    sub search {
        my ($self, $tree, $search) = @_;
        my $xpath = selector_to_xpath($search, './');
        my @results = $tree->findnodes($xpath);
        return @results;
    }
};
