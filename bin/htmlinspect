#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;
use utf8;

use open IO => ":locale";

use HTML::TreeBuilder;
use Getopt::Long;

our $opt_show_attributes;
our $opt_show_first_child;
our $opt_show_last_child;
our @opt_search;
our $opt_fancy;
our $opt_tree;
our $opt_theme = 'blank';

# gnu_compat disables ":s" options if a value is not supplied.

Getopt::Long::Configure("bundling", "gnu_compat", "no_ignore_case");
Getopt::Long::GetOptions(
    "s|search=s"                   => \@opt_search,
    "f|fancy"                      => \$opt_fancy,
    "a|attributes|show-attributes" => \$opt_show_attributes,
    "first-child|show-first-child" => \$opt_show_first_child,
    "last-child|show-last-child"   => \$opt_show_last_child,
    "t|tree"                       => \$opt_tree,
    "T|theme|tree-theme=s" => sub {
        my $value = $_[1];
        if ($value ne "blank" && $value ne "ascii" && $value ne "light" && $value ne "heavy") {
            die("Invalid tree theme: $value\n");
        }
        $opt_tree = 1;
    },
    "blank" => sub { $opt_theme = "blank"; $opt_tree = 1; },
    "ascii" => sub { $opt_theme = "ascii"; $opt_tree = 1; },
    "light" => sub { $opt_theme = "light"; $opt_tree = 1; },
    "heavy" => sub { $opt_theme = "heavy"; $opt_tree = 1; },
    "h|help" => sub { usage(); exit 0; }
) or die("Type '$0 --help' for help.\n");

sub usage { print <<"END"; }
usage:
  htmlinspect [<option> ...] [<file> ...]
options:
  -h, --help
  -a, --[show-]attributes
  -s, --search='<search>'     <tag>  and/or  .<class>  and/or  #<id>
  -f, --fancy
      --[show-]first-child
      --[show-]last-child
  -t, --tree
  -T, --tree-theme=<theme>    blank, ascii, light, heavy
END

local $/ = undef;
while (<>) {
    my $tree = HTML::TreeBuilder->new();
    $tree->parse($_);
    $tree->eof();
    $tree->elementify();
    if (scalar @opt_search) {
        my @elements = search($tree, @opt_search);
        foreach my $element (@elements) {
            htmlinspect($element, $ARGV);
        }
    } else {
        htmlinspect($tree, $ARGV);
    }
}

our $box_drawing;
BEGIN {
    $box_drawing = {
        light => {
            last            => "└── ",
            not_last        => "├── ",
            parent_last     => "    ",
            parent_not_last => "│   ",
        },
        heavy => {
            last            => "┗━━ ",
            not_last        => "┣━━ ",
            parent_last     => "    ",
            parent_not_last => "┃   ",
        },
        ascii => {
            last            => "`-- ",
            not_last        => "|-- ",
            parent_last     => "    ",
            parent_not_last => "|   ",
        },
        blank => {
            last            => "    ",
            not_last        => "    ",
            parent_last     => "    ",
            parent_not_last => "    ",
        },
    };
}

our %filename_printed;

sub htmlinspect {
    my ($element, $filename, %args) = @_;

    if (!ref($element)) {
        return;
    }
    my $tagname = $element->tag;

    my $index     = $args{index};
    my $nchildren = $args{nchildren};
    my $level     = $args{level} // 0;
    my $parents   = $args{parents} // [];
    my $prefix    = $args{prefix} // "";

    my @parents = @$parents;
    my $parents_string = join("", map { "$_ " } @$parents);

    my $class = $element->attr('class');
    my $id    = $element->attr('id');
    my @class = defined $class ? split(' ', $class) : ();

    my $suffix = "";
    $suffix .= ".$_" foreach @class;
    $suffix .= "#$id" if defined $id;

    if ($opt_show_attributes) {
        my @attr_names = sort { lc($a) cmp lc($b) } grep { $_ ne "class" && $_ ne "id" && $_ ne "/" } $element->all_external_attr_names;
        # bug: attributes named / show up for <.../> empty tags
        foreach my $attr_name (@attr_names) {
            $suffix .= sprintf("[%s]", $attr_name);
        }
    }
    if (defined $index) {
        if ($opt_show_first_child && $index == 0) {
            $suffix .= ":first-child";
        }
        if ($opt_show_last_child && $index == $nchildren - 1) {
            $suffix .= ":last-child";
        }
    }

    if ($opt_fancy) {
        if (!$filename_printed{$filename}) {
            print "$filename:\n";
            $filename_printed{$filename} = 1;
        }
        print " " x 4;
    } else {
        print "$filename: ";
    }

    my $newprefix;
    if ($opt_tree) {
        if ($opt_theme ne "blank") {
            my $drawing;
            if ($level) {
                $drawing = ($index == $nchildren - 1) ? $box_drawing->{$opt_theme}->{last} : $box_drawing->{$opt_theme}->{not_last};
            } else {
                $drawing = "";
            }
            print($prefix, $drawing);
            $newprefix = $prefix;
            if ($level) {
                $newprefix .= (($index == $nchildren - 1) ? $box_drawing->{$opt_theme}->{parent_last} : $box_drawing->{$opt_theme}->{parent_not_last});
            }
        } else {
            print(" " x (4 * $level));
        }
    } else {
        print($parents_string);
    }
    print($tagname, $suffix, "\n");

    {
        my @children = grep { ref $_ } $element->content_list();
        my $index = 0;
        my $nchildren = scalar @children;
        my %args;
        if ($opt_tree && $opt_theme ne "blank") {
            $args{prefix} = $newprefix;
        }
        foreach my $child (@children) {
            htmlinspect($child,
                        $filename,
                        %args,
                        parents => [@parents, $tagname . $suffix],
                        index => $index,
                        nchildren => $nchildren,
                        level => $level + 1);
            $index += 1;
        }
    }
}

sub search {
    my ($tree, @search) = @_;
    my @or;
    foreach my $search (@search) {
        my @and;
        while ($search =~ s{(?:([\.\#])([A-Za-z][A-Za-z0-9\-\_\:\.]*))$}{}x) {
            my ($prefix, $token) = ($1, $2);
            if ($prefix eq ".") {
                push(@and, sub {
                         my $class = $_[0]->attr('class');
                         return defined $class && $class =~ m{(^|\s)\Q$token\E($|\s)};
                     });
            } else {
                push(@and, sub {
                         my $id = $_[0]->attr('id');
                         return defined $id && $id eq $token;
                     });
            }
        }
        if ($search ne '') {
            push(@and, sub {
                     my $tagname = $_[0]->tag;
                     return defined $tagname && $tagname eq $search;
                 });
        }
        push(@or, \@and);
    }
    my $sub = sub {
        my $element = $_[0];
      orr:
        foreach my $or (@or) {
            foreach my $and (@$or) {
                if (!$and->($element)) {
                    next orr;
                }
            }
            return 1;
        }
        return 0;
    };
    return $tree->look_down($sub);
}
