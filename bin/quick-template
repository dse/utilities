#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;

use Text::Trim qw(trim);
use Getopt::Long;

my $template;
my $separator;
my $verbose = 0;

Getopt::Long::Configure('bundling', 'gnu_compat', 'no_ignore_case');
Getopt::Long::GetOptions(
    'v|verbose+' => \$verbose,
) or die("Type '$0 --help' for help.\n");

sub do_template {
    $template .= $_ . "\n";
}

sub do_data {
    return unless /\S/;
    if (defined($template)) {
        if ($separator ne "\t") {
            $_ = trim($_);
        }
	my @data = split($separator, $_);
	my $out = $template;
        $out =~ s{ \$ (\$|\d+) }{ ($1 eq '$') ? '$' : ($data[$1 - 1] // '') }xge;
	print($out);
    }
}

my $action;

while (<>) {
    s{\R\z}{};                  # safer chomp()
    say STDERR sprintf("%6d. %s", $., $_) if $verbose >= 2;
    if (m{^\s*\{\s*template\s*\}\s*$}i || m{\{\{\s*template\s*\}\}}i) {
        $template = '';
        $action = 'template';
        next;
    } elsif (m{^\s*\{\s*data\b(?:\s*(\S+?))?\s*\}\s*$}i || m{\{\{\s*data\b(?:\s*(\S+?))?\s*\}\}}i) {
        $separator = $1 // "\t";
        $action = 'data';
        next;
    } elsif (m{^\s*\{\s*(?:end|comment)\s*\}\s*$}i || m{\{\{\s*(?:end|comment)\s*\}\}}i) {
        $action = undef;
        next;
    } elsif (!defined $action) {
        say $_;
        next;
    } elsif ($action eq 'template') {
        do_template();
        next;
    } elsif ($action eq 'data') {
        do_data();
        next;
    }
}
