#!/usr/bin/env bash

# # NOTES FOR EVENTUAL DOCUMENTATION
#
# `-r` is specified for grep(1) if ALL of the following are true:
#
#   - there are no filename arguments
#   - `-r` is not already specified
#   - `-R` is not already specified
#   - no options triggering the use of find(1) are specified.
#
# These are the options that trigger the use of find(1):
#
#   - `--mindepth`
#   - `--maxdepth`

dirname="$(dirname "$0")"
progname="$(basename "$0")"

# shellcheck disable=SC1090
. "${dirname}/../share/utilities/findd-grepp.bash"

grepp_exclude_binary_files=1    # default for grepp

declare -a grep_options
declare -a grep_patterns        # -e <arg> or -f <arg>

grep_options=()
grep_patterns=()

read_pattern_arg=1
has_pattern=0
use_find=0
find_only=0

maxdepth=""
mindepth=""
matcher=""                      # "", "-E", "-F", "-G", or "-P"
matcher_conflict=""

verbose=0
dry_run=0

usage () {
    "${grep}" --help
    echo
    echo "grepp - additional options:"
    echo "      --verbose"
    echo "      --dry-run"
    echo "      --no-excludes"
    echo "      --min-depth=DEPTH        causes grepp to use find instead of grep to recurse"
    echo "      --max-depth=DEPTH        \""
    echo "      --css-class='<class>'    CSS classes in HTML/SGML/XML files"
    echo "      --attribute='<attr>'     HTML/SVG/XML attributes"
    echo "      --attribute='<attr>-'    HTML/SVG/XML attribute prefix"
    echo "grep options having no effect if grepp uses find to recurse:"
    echo "      --directories=ACTION"
    echo "  -r, --recursive"
    echo "  -R, --dereference-recursive"
    echo "grepp does not accept -NUM; must use -C or --context=NUM"
}

sourcefirst () {
    local i
    for i ; do
        if [[ -r "$i" ]] ; then
            # shellcheck disable=SC1090
            source "$i"
            return $?
        fi
    done
    return 1
}

sourcefirst \
    "${HOME}/git/dse.d/getlongopts-bash/getlongopts.sh" \
    "/c/cygwin64/home/501475791/git/dse.d/getlongopts-bash/getlongopts.sh" \
    "${HOME}/git/dse.d/bash-getlongopts/getlongopts.sh" \
    "/c/cygwin64/home/501475791/git/dse.d/bash-getlongopts/getlongopts.sh" || {
    >&2 echo "Error finding a getlongopts.sh to source."
    exit 1
}

declare -a longopts
longopts=(
    help                   no
    version                no
    extended-regexp        no
    fixed-strings          no
    basic-regexp           no
    perl-regexp            no
    regexp                 yes
    file                   yes
    ignore-case            no
    invert-match           no
    word-regexp            no
    line-regexp            no
    count                  no
    color                  optional
    colour                 optional
    files-without-match    no
    files-with-matches     no
    max-count              yes
    only-matching          no
    quiet                  no
    silent                 no
    no-messages            no
    byte-offset            no
    with-filename          no
    no-filename            no
    label                  yes
    line-number            no
    initial-tab            no
    unix-byte-offsets      no
    null                   no
    after-context          yes
    before-context         yes
    context                yes
    text                   no
    binary-files           yes
    devices                yes
    directories            yes
    exclude                yes
    exclude-from           yes
    exclude-dir            yes
    include                yes
    recursive              no
    dereference-recursive  no
    line-buffered          no
    binary                 no
    null-data              no

    verbose                no
    dry-run                no
    no-excludes            no
    max-depth              yes
    maxdepth               yes
    min-depth              yes
    mindepth               yes
    css-class              yes
    non-ascii              no
    non-ascii-printable    no
    attribute              yes
    html-attribute         yes
    sgml-attribute         yes
    xml-attribute          yes

    exclude-binaries       no
    exclude-binary         no
    exclude-binary-files   no
    include-binaries       no
    include-binary         no
    include-binary-files   no

    find-only no
    findd-only no
    list-only no

    use-find no
    use-findd no

    findd-exclude yes
    findd-include yes

    emacs                  no
)

require_matcher () {
    local new_matcher="$1"
    local new_matcher_conflict="$2"
    case "${matcher}" in
        "")
            matcher="${new_matcher}"
            grep_options+=("${new_matcher}")
            ;;
        "-P")
            ;;
        *)
            if [[ -n "${matcher_conflict}" ]] ; then
                >&2 echo "${progname}: ${new_matcher} conflicts with ${matcher_conflict}"
            else
                >&2 echo "${progname}: ${new_matcher} conflicts with ${matcher}"
            fi
            exit 1
            ;;
    esac
    matcher_conflict="${new_matcher_conflict}"
}

opt_css_class () {
    local classname="$1"
    local rx="(?x: (?<=^|[[:space:]])
                   class
                   [[:space:]]*=[[:space:]]*
                   (?: \"(?:[^\"]*[[:space:]])?(?:${classname})(?:[[:space:]][^\"]*)?\"
                     | '(?:[^']*[[:space:]])?(?:${classname})(?:[[:space:]][^']*)?'
                     | (?:${classname})
                       (?= \$
                         | [[:space:]]
                         | >
                         | /
                       )
                   )
              )"
    rx="${rx//$'\n'/ }"
    read_pattern_arg=0
    has_pattern=1
    grep_patterns+=(
        "-e"
        "${rx}"
    )
    require_matcher "-P" "--css-class"
}

opt_attribute () {
    local attrname="$1"
    if [[ "$attrname" = *"-" ]] ; then
        attrname="${attrname}[A-Za-z0-9-]*"
    fi
    local rx="(?x: (?<=^|[[:space:]])
                   (?:${attrname})
                   (?: [[:space:]]*=[[:space:]]*
                       (?: \"[^\"]*\"
                         | '[^']*'
                         | [^\"'[:space:]]+
                       )
                   )?
              )"
    rx="${rx//$'\n'/ }"
    read_pattern_arg=0
    has_pattern=1
    grep_patterns+=(
        "-e"
        "${rx}"
    )
    require_matcher "-P" "--attribute"
}

opt_non_ascii () {
    read_pattern_arg=0
    has_pattern=1
    grep_patterns+=(
        "-e"
        "[^[:ascii:]]"
    )
    require_matcher "-P" "--non-ascii"
}

opt_non_ascii_printable () {
    read_pattern_arg=0
    has_pattern=1
    grep_patterns+=(
        '-e'
        $'[^[:print:]\r\t]'     # can't specify \n here, triggers grep(1) error
    )
    require_matcher "-P" "--non-ascii-printable"
}

opt_matcher () {
    local new_matcher="$1"
    case "${matcher}" in
        "")
            matcher="${new_matcher}"
            grep_options+=("${new_matcher}")
            ;;
        "${new_matcher}")
            ;;
        *)
            if [[ -n "${matcher_conflict}" ]] ; then
                >&2 echo "${progname}: ${new_matcher} conflicts with ${matcher_conflict}"
            else
                >&2 echo "${progname}: conflicting matchers specified"
            fi
            exit 1
            ;;
    esac
}

check_for_emacs_grep=1

while getlongopts 'VEFGPivwxycLloqsbHhnTuZaIrRUze:f:m:A:B:C:D:d:' OPTION "${longopts[@]}" -- "$@" ; do
    case "${OPTION}" in

        "?")
            exit 1
            ;;

        # takes no arguments; specifies a matcher
        E|extended-regexp) opt_matcher "-E";;
        F|fixed-strings)   opt_matcher "-F";;
        G|basic-regexp)    opt_matcher "-G";;
        P|perl-regexp)     opt_matcher "-P";;

        # takes no arguments; pass to grep
        V|i|v|w|x|y|c|L|l|o|q|s|b|H|h|n|T|u|Z|a|I|U|z)
            # NOTE: There is no need to pass -r to grep when using
            # find, but it's also harmless.
            grep_options+=(
                -"${OPTION}"
            )
            ;;

        # takes no arguments; pass to grep
        r)
            opt_r=1
            opt_R=0
            grep_options+=("-${OPTION}")
            ;;
        R)
            opt_r=0
            opt_R=1
            grep_options+=("-${OPTION}")
            ;;

        # takes an argument; pass to grep
        e|f)
            read_pattern_arg=0
            has_pattern=1
            grep_patterns+=(
                -"${OPTION}"
                "${OPTARG}"
            )
            ;;

        # takes an argument; pass to grep
        m|A|B|C|D|d)
            grep_options+=(
                -"${OPTION}"
                "${OPTARG}"
            )
            ;;

        "help")
            usage
            exit 0
            ;;
        "version")
            exec "${grep}" --version
            ;;
        "verbose")
            verbose=$((verbose + 1))
            ;;
        "dry-run")
            dry_run=1
            ;;
        "no-excludes")
            # shellcheck disable=SC2034
            directory_excludes=()
            # shellcheck disable=SC2034
            file_excludes=()
            # shellcheck disable=SC2034
            file_excludes_binary=()
            ;;
        "exclude-binaries"|"exclude-binary"|"exclude-binary-files")
            # shellcheck disable=SC2034
            grepp_exclude_binary_files=1
            ;;
        "include-binaries"|"include-binary"|"include-binary-files")
            # shellcheck disable=SC2034
            grepp_exclude_binary_files=0
            ;;
        "regexp"|"file")
            read_pattern_arg=0
            has_pattern=1
            grep_patterns+=(
                "${LONGOPTARGS[@]}"
            )
            ;;
        "recursive")
            opt_r=1
            opt_R=0
            grep_options+=(
                "${LONGOPTARGS[@]}"
            )
            ;;
        "dereference-recursive")
            opt_r=0
            opt_R=1
            grep_options+=(
                "${LONGOPTARGS[@]}"
            )
            ;;
        "maxdepth"|"max-depth")
            maxdepth="${OPTARG}"
            use_find=1
            ;;
        "mindepth"|"min-depth")
            mindepth="${OPTARG}"
            use_find=1
            ;;

        "css-class")
            opt_css_class "${OPTARG}"
            ;;
        "attribute"|"html-attribute"|"sgml-attribute"|"xml-attribute")
            opt_attribute "${OPTARG}"
            ;;
        "non-ascii")
            opt_non_ascii
            ;;
        "non-ascii-printable")
            opt_non_ascii_printable
            ;;

        "find-only"|"findd-only"|"list-only")
            find_only=1
            ;;

        "emacs")
            check_for_emacs_grep=0
            grep_options+=(--color -n -H)
            ;;

        "findd-exclude")
            add_user_exclude "${OPTARG}"
            ;;
        "findd-include")
            add_user_include "${OPTARG}"
            ;;

        "use-find"|"use-findd")
            use_find=1
            ;;

        "exclude"|"exclude-dir"|"include")
            lc="${OPTARG,,}"
            uc="${OPTARG^^}"
            grep_options+=("--${OPTION}=${lc}")
            grep_options+=("--${OPTION}=${uc}")
            if [[ "${OPTARG}" != "${lc}" ]] && [[ "${OPTARG}" != "${uc}" ]] ; then
                grep_options+=("--${OPTION}=${OPTARG}")
            fi
            ;;

        # other long options are passed to grep
        # for now, includes --exclude-from
        ??*)
            grep_options+=(
                "${LONGOPTARGS[@]}"
            )
            ;;

        # other short option
        *)
            >&2 echo "grepp: UNEXPECTED short option: -$OPTION"
            exit 1
            ;;
    esac
done
shift $((OPTIND - 1))

if (( check_for_emacs_grep )) ; then # default
    if [[ "${TERM}" = "emacs-grep" ]] ; then # M-x find-grep
        grep_options+=(--color -n -H)
    elif [[ "${TERM}" = "dumb" ]] && [[ -n "${INSIDE_EMACS}" ]] ; then
        grep_options+=(--color -n -H)
    fi
fi

if (( verbose >= 2 )) ; then
    >&2 echo "after option processing"
    # shellcheck disable=SC2145
    >&2 echo "  grep_options=(${grep_options[@]@Q})"
    # shellcheck disable=SC2145
    >&2 echo "  grep_patterns=(${grep_patterns[@]@Q})"
    # shellcheck disable=SC2145
    >&2 echo "  @=(${@@Q})"
fi

if (( read_pattern_arg )) ; then
    if (( $# )) ; then
        has_pattern=1
        grep_patterns+=(
            "-e"
            "$1"
        )
        shift
    else
        >&2 echo "grepp: missing pattern argument"
        exit 1
    fi
fi

if (( ! has_pattern )) ; then
    >&2 echo "grepp: missing pattern argument"
    exit 1
fi

if (( ! $# )) ; then
    set -- .
fi

# Why would you *not* use this tool to recurse?
if (( ! opt_r && ! opt_R )) ; then
    # There is no need to pass -r to grep when using find.
    if (( ! use_find )) ; then
        grep_options+=(
            -r
        )
    fi
fi

if (( verbose >= 2 )) ; then
    >&2 echo "after additional option processing"
    # shellcheck disable=SC2145
    >&2 echo "  grep_options=(${grep_options[@]@Q})"
    # shellcheck disable=SC2145
    >&2 echo "  grep_patterns=(${grep_patterns[@]@Q})"
    # shellcheck disable=SC2145
    >&2 echo "  @=(${@@Q})"
fi

if (( find_only )) ; then
    set_find_excludes
    declare -a find_command
    find_command=(
        "${find}"
        "$@"
        ${mindepth:+-mindepth "${mindepth}"}
        ${maxdepth:+-maxdepth "${maxdepth}"}
        \! \( -type d \( "${find_directory_excludes[@]}" \) -prune \)
        -type f
        \! \( "${find_file_excludes[@]}" \)
        -ls
    )

    if (( verbose >= 1 || dry_run )) ; then
        echo_command "${find_command[@]}"
    fi

    if (( dry_run )) ; then
        exit 0
    fi

    exec "${find_command[@]}"
elif (( use_find )) ; then
    set_find_excludes
    declare -a find_command
    find_command=(
        find
        "$@"
        ${mindepth:+-mindepth "${mindepth}"}
        ${maxdepth:+-maxdepth "${maxdepth}"}
        \! \( -type d \( "${find_directory_excludes[@]}" \) -prune \)
        -type f
        \! \( "${find_file_excludes[@]}" \)
        -exec
        "${grep}"
        "${grep_options[@]}"
        "${grep_patterns[@]}"
        {} +
    )

    if (( verbose >= 1 || dry_run )) ; then
        echo_command "${find_command[@]}"
    fi

    if (( dry_run )) ; then
        exit 0
    fi

    exec "${find_command[@]}"
else
    set_grep_excludes

    declare -a grep_command
    grep_command=(
        "${grep}"
        "${grep_options[@]}"
        "${grep_directory_excludes[@]}"
        "${grep_file_excludes[@]}"
        "${grep_patterns[@]}"
        "$@"
    )

    if (( verbose >= 1 || dry_run )) ; then
        echo_command "${grep_command[@]}"
    fi

    if (( dry_run )) ; then
        exit 0
    fi

    exec "${grep_command[@]}"
fi
