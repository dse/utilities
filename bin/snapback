#!/usr/bin/env bash
set -o errexit
set -o pipefail
set -o nounset
# set -o xtrace

PROGNAME="$(basename "$0")"

# snapback:
#     local to local or local to remote

MAIN () {
    local hostname
    local -a rsync_options
    local srcdir
    local destuserhost
    local destdir
    local keyfile
    local identityfile

    keyfile="${HOME}/.ssh/snapback.pem"
    identityfile="${keyfile}.pub"

    hostname="$(hostname -s)"
    hostname="${hostname%%.*}"

    rsync_options=()
    rsync_options+=(--partial)
    rsync_options+=(--archive)
    rsync_options+=(--verbose)
    rsync_options+=(--progress)
    rsync_options+=(--delete)
    rsync_options+=(--hard-links)

    # --archive includes:
    #     -r, --recursive
    #     -l, --links
    #     -p, --perms
    #     -t, --times
    #     -g, --group
    #     -o, --owner
    #     -D, --devices --specials
    #     no -H (--hard-links)
    #     no -A (--acls)
    #     no -X (--xattrs)

    srcdir="${HOME}"
    destuserhost="dse@nas.webonastick.com"
    destdir="backups/${hostname}"

    while (( $# > 0 )) && [[ "$1" == '-'* ]] ; do
        case "$1" in
            -x)
                set -o xtrace
                ;;
            *)
                >&2 echo "snapback: unknown option: $1"
                exit 1
                ;;
        esac
        shift
    done

    if (( $# == 0 )) ; then
        KEYGEN -q "${srcdir}" "${destuserhost}" "${destdir}"
        SNAPBACK "${srcdir}" "${destuserhost}" "${destdir}"
    elif (( $# == 1 )) ; then
        case "$1" in
            make-backup|makebackup|backup)
                KEYGEN -q "${srcdir}" "${destuserhost}" "${destdir}"
                SNAPBACK "${srcdir}" "${destuserhost}" "${destdir}"
                ;;
            make-lists|makelists|lists)
                KEYGEN -q "${srcdir}" "${destuserhost}" "${destdir}"
                MAKELISTS "${srcdir}" "${destuserhost}" "${destdir}"
                ;;
            keygen)
                KEYGEN -f "${srcdir}" "${destuserhost}" "${destdir}"
                ;;
            remove-keys)
                rm "${keyfile}" || true
                rm "${identityfile}" || true
                REMOVEKEYS "${srcdir}" "${destuserhost}" "${destdir}"
                ;;
            *)
                >&2 echo "${PROGNAME}: unknown subcommand: $1"
                ;;
        esac
    else
        >&2 echo "${PROGNAME}: incorrect number of arguments: $#"
        exit 1
    fi
}

SNAPBACK () {
    local srcdir="$1"
    local destuserhost="$2"
    local destdir="$3"

    # new or interrupted snapshot: ${destdir}/tmp
    # symlink to latest snapshot:  ${destdir}/latest
    # each snapshot dirname:       <epoch>-<YYYYMMDD>T<HHMMSS><+-ZZZZ>

    if [[ "${destuserhost}" = "" ]] ; then
        >&2 echo "${PROGNAME}: blank <user>@<host> not supported."
        exit 1
    fi

    if [[ "${destuserhost}" = "" ]] ; then
        if ! test -e "${destdir}" ; then
            mkdir -p "${destdir}"
        fi
        if test -e "${destdir}"/latest ; then
            RSYNC "${rsync_options[@]}" \
                  --link-dest=../latest \
                  "${srcdir}/" \
                  "${destdir}"/tmp
        else
            RSYNC "${rsync_options[@]}" \
                  "${srcdir}/" \
                  "${destdir}"/tmp
        fi
    else
        if ! SSH "${destuserhost}" test -e "${destdir}" ; then
            SSH "${destuserhost}" mkdir -p "${destdir}"
        fi
        if SSH "${destuserhost}" test -e "${destdir}"/latest ; then
            RSYNC "${rsync_options[@]}" \
                  --link-dest=../latest \
                  "${srcdir}/" \
                  "${destuserhost}":"${destdir}"/tmp
        else
            RSYNC "${rsync_options[@]}" \
                  "${srcdir}/" \
                  "${destuserhost}":"${destdir}"/tmp
        fi
    fi

    snapshotname="$(date '+%s-%Y-%m-%dT%H%M%S%z')"

    if [[ "${destuserhost}" = "" ]] ; then
        (
            cd "${destdir}"
            mv tmp "${snapshotname}"
            ln -n -f -s "${snapshotname}" latest
        )
    else
        SSH "${destuserhost}" "
            cd ${destdir@Q} &&
            mv tmp ${snapshotname@Q} &&
            ln -n -f -s ${snapshotname@Q} latest
        "
    fi
}

MAKELISTS () {
    local srcdir="$1"
    local destuserhost="$2"
    local destdir="$3"

    if [[ "${destuserhost}" = "" ]] ; then
        :                       # FIXME: does nothing
    else
        MAKEREMOTESCRIPTS
        SSH "${destuserhost}" -t "~/bin/makelists ${destdir@Q}"
    fi
}

MAKEREMOTESCRIPT () {
    local scriptname="$1"
    SSH "${destuserhost}" "
        mkdir -p ~/bin &&
        cat > ${scriptname} &&
        chmod 0755 ${scriptname}
    "
}

MAKEREMOTESCRIPTS () {
    MAKEREMOTESCRIPT '~/bin/poormanspv' <<'EOF'
#!/usr/bin/env bash
# for printing progress in a pipe, like the real pv utility

awk '
{
    print($0)
    if (NR % 100 == 0) {
        printf("    %d lines\r", NR) >"/dev/tty"
    }
}
END {
    printf("    %d lines, done.\n", NR) >"/dev/tty"
}
'
EOF

    MAKEREMOTESCRIPT '~/bin/findlist' <<'EOF'
#!/usr/bin/env bash
# reformat the output of 'find . -type f -ls' to make it
# diffable by doing the following:
#
# - remove the number of hard links, in case that's the only
#   thing that changes about a file, i.e., hard links are
#   added or removed.
#
# - fixed column widths

awk '{
    printf("%12d %12d %s %-8s %-8s %12d %-3s %2s %5s %s\n",
           $1, $2, $3, $5, $6, $7, $8, $9, $10, $11);
}'
EOF

    MAKEREMOTESCRIPT '~/bin/makelists' <<'EOF'
#!/usr/bin/env bash
# generate backup listing files

set -o errexit
set -o pipefail
set -o nounset
shopt -s nullglob               # in case there are no listing files

destdir="$1"
cd "${destdir}"
for snapshotname in [0-9]*-????-??-??T??????[-+]???? ; do
    findlistfile="${snapshotname}.txt"
    if [[ -s "${findlistfile}" ]] ; then
        >&2 echo "${findlistfile} already exists"
    else
        >&2 echo "generating ${findlistfile}...."
        (
            cd "${snapshotname}"
            find . -type f -ls
        ) | ~/bin/poormanspv | ~/bin/findlist > "${findlistfile}.tmp.1"
        >&2 echo "    sorting..."
        sort -k10.1 < "${findlistfile}.tmp.1" > "${findlistfile}.tmp"
        if [[ -s "${findlistfile}.tmp" ]] ; then
            mv "${findlistfile}.tmp" "${findlistfile}"
            rm "${findlistfile}.tmp.1"
        fi
        >&2 echo "    done."
    fi
done
EOF
}

KEYGEN () {
    # generate a new key for this host

    local force=0
    local quiet=0

    while (( $# )) && [[ "$1" = -* ]] ; do
        case "$1" in
            -f|--force)
                force=1
                ;;
            -q|--quiet)
                quiet=1
                ;;
            *)
                >&2 echo "${PROGNAME} KEYGEN: unknown option: $1"
                ;;
        esac
        shift
    done

    local srcdir="$1"
    local destuserhost="$2"
    local destdir="$3"
    local comment

    if [[ "${destuserhost}" = "" ]] ; then
        :                       # FIXME
    else
        if [[ -e "${keyfile}" ]] ; then
            if (( ! force )) ; then
                (( quiet )) || >&2 echo "Key exists.  Use -f/--force to overwrite."
                return
            fi
        fi

        comment="snapback@@${hostname} $(date '+%Y-%m-%dT%H%M%S%z')"

        ssh-keygen -f "${keyfile}" -N "" -C "${comment}" <<<"y"
        # <<<"y" feeds "y" to the overwrite prompt if key already exists

        chmod 0600 "${keyfile}" "${identityfile}"

        ssh-copy-id -i "${identityfile}" "${destuserhost}"
    fi
}

REMOVEKEYS () {
    # only remove (old) keys for this host
    local srcdir="$1"
    local destuserhost="$2"
    local destdir="$3"

    if [[ "${destuserhost}" = "" ]] ; then
        :                       # FIXME
    else
        >&2 echo "Removing snapback keys..."
        sed "s/{{HOSTNAME}}/${hostname}/g" <<'EOF' | SSH -T "${destuserhost}"
            set -o errexit
            set -o pipefail
            set -o nounset
            sed -i.bak -r '
                /[^ ] snapback@@{{HOSTNAME}} /{
                    s/^/    Removing: /
                    w /dev/stderr
                    d
                }
            ' ~/.ssh/authorized_keys
EOF
        >&2 echo "    Done."
    fi
}

SSH () {
    ssh -i "${keyfile}" "$@"
}

RSYNC () {
    local status
    if rsync -e "ssh -i ${keyfile@Q}" "${@}" ; then
        status=0
    else
        status=$?
    fi
    if [[ "${status}" = 23 ]] ; then
        >&2 echo ">>> rsync returned exit code ${status}; continuing."
        return 0
    fi
    return "${status}"
}

###############################################################################
MAIN "$@"
