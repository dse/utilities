#!/usr/bin/env perl
use warnings;
use strict;
use Scalar::Util qw(looks_like_number);
use POSIX qw(:math_h);
use POSIX qw(:math_h_c99);
use Math::Trig qw(:pi);
use Math::Trig qw(:radial);
use Math::Trig qw(:great_circle);
our $last_result = 0;
sub _ {
    return $last_result;
}
# supported:
#     {{ expr }}
#     {{ expr | fmt }}
#     {{ expr = }}
#     {{ expr = | fmt }}
#     {{ expr = text }}
#     {{ expr = text | fmt }}
# possible alternatives to |
# would be things not expected to appear in the expression
#     {{ expr = text ;; fmt }}
#     {{ expr = text # fmt }}
#     {{ expr = text ||| fmt }}
#     {{ expr = text %%fmt }}
#     {{ expr = text % %fmt }}
# todo:
#     interactive line-by-line?
#     filenames on CLI?
#     exprs on CLI?
while (<>) {
    s{(?<start>\{\{)
      (?<sp1>\s*)
      (?<expr>\S.*?)
      (?<sp2>\s*)
      (?:
          (?<eq>=>?)
          (?<sp3>\s*)
          (?:
              (?<repl>\S.*?)
              (?<sp4>\s*)
          )?
      )?
      (?<pipe_fmt>
          (?<pipe>\|)
          (?<sp5>\s*)
          (?:
              (?<fmt>\S.*?)
              (?<sp6>\s*)
          )?
      )?
      (?<end>\}\})}
     { replace($&, %+) }gex;
    print;
}
sub replace {
    my ($M, %A) = @_;
    my $eval = evaluate($A{expr}, $A{fmt});
    if ($@) {
        warn($@);
        return $M;
    }
    if (defined $A{eq}) {
        return $A{start} . $A{sp1} . $A{expr} . $A{sp2} . $A{eq} . $A{sp3} . $eval . ($A{sp4} // $A{sp3}) . ($A{pipe_fmt} // '') . $A{end};
    }
    return $A{start} . $A{sp1} . $eval . $A{sp2} . $A{end};
}
sub evaluate {
    my ($expr, $fmt) = @_;
    return $expr if looks_like_number($expr) && !defined $fmt;
    $expr =~ s{\N{MULTIPLICATION SIGN}}{*}g;
    $expr =~ s{\N{DIVISION SIGN}}{/}g;
    $expr =~ s{\N{MINUS SIGN}}{-}g;
    $expr =~ s{\N{NOT SIGN}}{!}g;
    $expr =~ s{\N{INFINITY}}{('inf' + 1)}g;
    $expr =~ s{\N{LOGICAL OR}}{||}g;
    $expr =~ s{\N{LOGICAL AND}}{&&}g;
    $expr =~ s{\N{LESS-THAN OR EQUAL TO}}{<=}g;
    $expr =~ s{\N{GREATER-THAN OR EQUAL TO}}{>=}g;
    my $result = eval($expr);
    if (defined $result) {
        $last_result = $result;
    }
    $result = sprintf($fmt, $result) if defined $result && defined $fmt;
    return $result;
}
