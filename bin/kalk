#!/usr/bin/env perl
use warnings;
use strict;
use Scalar::Util qw(looks_like_number);
use POSIX qw(:math_h);
use POSIX qw(:math_h_c99);
use Math::Trig qw(:pi);
use Math::Trig qw(:radial);
use Math::Trig qw(:great_circle);
our $last_result = 0;
sub _ () {
    # prototype required for things like "_ + 5" to work
    return $last_result;
}
# supported:
#     { expr }
#     { expr | fmt }
#     { expr = }
#     { expr = | fmt }
#     { expr = text }
#     { expr = text | fmt }
while (<>) {
    s{(?<start>\{)
      (?<sp1>\s*)
      (?<expr>\S.*?)
      (?<sp2>\s*)
      (?:
          (?<eq>=>?)
          (?<sp3>\s*)
          (?:
              (?<repl>\S.*?)
              (?<sp4>\s*)
          )?? (?# non-greedy in case char after '=' is '|' )
      )?
      (?<pipe_fmt>
          (?<pipe>\|)
          (?<sp5>\s*)
          (?:
              (?<fmt>\S.*?)
              (?<sp6>\s*)
          )?
      )?
      (?<end>\})}
     { replace($&, %+) }gex;
    print;
}
sub replace {
    my ($match, %group) = @_;
    my $eval = evaluate($group{expr}, $group{fmt});
    if ($@) {
        warn($@);
        return $match;
    }
    if (defined $group{eq}) {
        return $group{start} . $group{sp1} . $group{expr} . $group{sp2} . $group{eq} . $group{sp3} . $eval . ($group{sp4} // $group{sp3}) . ($group{pipe_fmt} // '') . $group{end};
    }
    return $group{start} . $group{sp1} . $eval . $group{sp2} . $group{end};
}
sub evaluate {
    my ($expr, $fmt) = @_;
    return $expr if looks_like_number($expr) && !defined $fmt;
    my $result = eval($expr);
    if (defined $result) {
        $last_result = $result;
    }
    $result = sprintf($fmt, $result) if defined $result && defined $fmt;
    return $result;
}
