#!/usr/bin/env perl
#
# align - a utility influenced by M-x align-regexp.
# But more powerful because it uses Perl regular expressions.
#
use warnings;
use strict;
use v5.10.0;

use open qw(:locale);
use Encode::Locale;
use Encode qw(decode);
BEGIN {
    @ARGV = map { decode('locale', $_, Encode::FB_CROAK) } @ARGV;
}

use Getopt::Long;
use List::Util qw(max all min);
use Data::Dumper qw(Dumper);
use Text::Tabs qw(expand);

local $Data::Dumper::Indent   = 0;
local $Data::Dumper::Terse    = 1;
local $Data::Dumper::Deepcopy = 1;
local $Data::Dumper::Sortkeys = 1;
local $Data::Dumper::Useqq    = 1;

sub usage { print <<EOF; }
usage:
  align [<option> ...] <pattern> [<file> ...]
options:
  -b, --before             align spaces before <pattern> (default)
  -a, --after              align spaces after <pattern>
  -B, --no-before          do not align spaces before <pattern>
  -A, --no-after           do not align spaces after <pattern>
  -f, --fixed              interpret patterns as fixed strings
  -r, --regexp             interpret patterns as perl regexps (default)
  -i, --case-insensitive   case-insensitive pattern match
      --case-sensitive     case-sensitive pattern match (default)
  -e, --pattern=<pattern>  specify multiple patterns, like grep
  -m, --max-columns=<int>  specify maximum number of column alignments
      --repeat             repeat as many alignments as possible
EOF
###############################################################################

my $debug                = 0;
my $patternType          = 'regexp';
my $caseInsensitive      = 0;
my $maxColumns           = 1;   # 0 = infinity
my @patterns;
my $alignBefore;
my $alignAfter;
my $repeat               = 0;

Getopt::Long::Configure('bundling', 'gnu_compat', 'no_ignore_case');
Getopt::Long::GetOptions(
    'a|after|align-after'         => sub { $alignAfter  = 1; },
    'b|before|align-before'       => sub { $alignBefore = 1; },
    'A|no-after|no-align-after'   => sub { $alignAfter  = 0; },
    'B|no-before|no-align-before' => sub { $alignBefore = 0; },
    'debug+'                      => \$debug,
    'e|pattern=s'                 => sub {
        push(@patterns, {
            alignBefore     => $alignBefore,
            patternType     => $patternType,
            caseInsensitive => $caseInsensitive,
            pattern         => $_[1],
        });
    },
    'r|regexp'                    => sub { $patternType = 'regexp'; },
    'i|case-insensitive'          => \$caseInsensitive,
    'case-sensitive'              => sub { $caseInsensitive = 0; },
    'f|fixed'                     => sub { $patternType = 'fixed'; },
    'repeat'                      => \$repeat,
    'h|help'                      => sub { usage(); exit(0); },
) or die("Type '$0 --help' for help.\n");

if (!defined $alignBefore && !defined $alignAfter) {
    $alignBefore = 1;
    $alignAfter = 0;
} else {
    $alignBefore //= 0;
    $alignAfter //= 0;
}

if (!scalar @patterns) {
    if (!scalar @ARGV) {
        die("pattern must be specified.\n");
    }
    my $pattern = shift(@ARGV);
    push(@patterns, {
        alignBefore     => $alignBefore,
        alignAfter      => $alignAfter,
        patternType     => $patternType,
        caseInsensitive => $caseInsensitive,
        pattern         => $pattern
    });
}

foreach my $pattern (@patterns) {
    my $p = $pattern->{pattern};
    if ($debug) {
        print $p;
    }
    if ($pattern->{patternType} eq 'fixed') {
        $p = quotemeta($p);
        # $p = '\Q' . $p . '\E';
    }
    if ($pattern->{caseInsensitive}) {
        $p = qr{(\s*)($p)(\s*)}i;
    } else {
        $p = qr{(\s*)($p)(\s*)};
    }
    if ($debug) {
        say " => ", $p;
    }
    $pattern->{pattern} = $p;
}

my @lines;

while (<>) {
    s{\R\z}{};
    $_ = expand($_);
    push(@lines, {
        text => $_,
        filename => $ARGV,
        lineNumber => $.,
    });
}

my $cycleMatch;
do {
    $cycleMatch = 0;
  pattern:
    foreach my $pattern (@patterns) {
        foreach my $line (@lines) {
            if ($line->{text} =~ $pattern->{pattern}) {
                my ($preMatch, $spaceBefore, $match, $spaceAfter, $postMatch) =
                    ($`, $1, $2, $3, $');
                $line->{matches} = 1;
                $line->{result} = ($line->{result} // '') . $preMatch;
                $line->{spaceBefore} = $spaceBefore;
                $line->{match}       = $match;
                $line->{spaceAfter}  = $spaceAfter;
                $line->{text}        = $postMatch;
            } else {
                delete $line->{spaceBefore};
                delete $line->{match};
                delete $line->{spaceAfter};
            }
        }
        my @matchingLines = grep { $_->{matches} } @lines;
        if (!scalar @matchingLines) {
            next pattern;
        }
        $cycleMatch = 1;

        if ($pattern->{alignBefore}) {
            my $maxColumn = 1 + max(map { length $_->{result} } @matchingLines);
            foreach my $line (@matchingLines) {
                $line->{result} .= ' ' x ($maxColumn - length $line->{result});
                delete $line->{spaceBefore};
            }
        } else {
            foreach my $line (@matchingLines) {
                $line->{result} .= delete $line->{spaceBefore};
            }
        }

        foreach my $line (@matchingLines) {
            $line->{result} .= delete $line->{match};
        }

        if ($pattern->{alignAfter}) {
            my $maxColumn = 1 + max(map { length $_->{result} } @matchingLines);
            foreach my $line (@matchingLines) {
                if (length $line->{text}) {
                    $line->{result} .= ' ' x ($maxColumn - length $line->{result});
                }
                delete $line->{spaceAfter};
            }
        } else {
            foreach my $line (@matchingLines) {
                $line->{result} .= delete $line->{spaceAfter};
            }
        }
    }
} while ($repeat && $cycleMatch);

foreach my $line (@lines) {
    print $line->{result} if defined $line->{result};
    print $line->{text}, "\n";
}
