#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;
use utf8;

#------------------------------------------------------------------------------
use File::Basename qw(basename);
our $PROGNAME = basename($0);

#------------------------------------------------------------------------------
use open IO => qw(:locale);
use Encode::Locale;
use Encode qw(decode);
BEGIN {
    @ARGV = map { decode('locale', $_, Encode::FB_CROAK) } @ARGV;
}

#------------------------------------------------------------------------------
our @patterns;
our $repeat;
our $verbose = 0;

#------------------------------------------------------------------------------
use Getopt::Long;
Getopt::Long::Configure('bundling', 'gnu_compat', 'no_ignore_case');
Getopt::Long::GetOptions(
    'e|pattern=s' => sub {
        my $pattern = $_[1];
        push(@patterns, {
            regexp => qr{$pattern}
        });
    },
    'v|verbose+'  => \$verbose,
    'r|repeat'    => \$repeat,
    'h|help'      => sub { usage(); exit(0); },
) or die("Type '$PROGNAME --help' for help.\n");

if (!scalar @patterns) {
    if (!scalar @ARGV) {
        die("$PROGNAME: pattern must be specified\n");
    }
    my $pattern = shift(@ARGV);
    push(@patterns, {
        regexp => qr{$pattern}
    });
}

my $align = My::Align->new();
$align->patterns([@patterns]);
$align->repeat($repeat);
$align->verbose($verbose);
while (<>) {
    $align->addLine($_);
    if ($verbose) {
        warn("Read $. lines\n");
    }
}
$align->printAlignedLines();

#------------------------------------------------------------------------------
package My::Align {
    use Text::Tabs qw(expand);
    use List::Util qw(max);
    use Moo;
    INIT {
        has patterns     => (is => 'rw', default => sub { return []; });
        has lines        => (is => 'rw', default => sub { return []; });
        has repeat       => (is => 'rw', default => 0);
        has spacesBefore => (is => 'rw', default => 1);
        has spacesAfter  => (is => 'rw', default => 1);
        has alignBefore  => (is => 'rw', default => 1);
        has verbose      => (is => 'rw', default => 0);
    }
    sub addLine {
        my ($self, $text) = @_;
        $text =~ s{\R\z}{};     # safer chomp
        $text = expand($text);
        push(@{$self->lines}, {
            text => $text
        });
    }
    sub printAlignedLines {
        my ($self) = @_;
        $self->initLines();
        if ($self->repeat) {
            while (1) {
                if (!$self->runPatterns()) {
                    last;
                }
            }
        } else {
            $self->runPatterns();
        }
        $self->finalizeLines();
        $self->printLines();
    }
    sub initLines {
        my ($self) = @_;
        foreach my $line (@{$self->lines}) {
            $line->{result} = '';
            delete $line->{match};
            delete $line->{post};
            $line->{buffer} = $line->{text};
        }
    }
    sub finalizeLines {
        my ($self) = @_;
    }
    sub runPatterns {
        my ($self) = @_;
        my $match = 0;
        foreach my $pattern (@{$self->patterns}) {
            if ($self->runPattern($pattern)) {
                $match = 1;
            }
        }
        return $match;
    }
    sub runPattern {
        my ($self, $pattern) = @_;
        my $regexp = $pattern->{regexp};
        my $match = 0;
        if ($self->verbose) {
            warn("Running pattern [$regexp]\n");
        }
        foreach my $line (@{$self->lines}) {
            if ($line->{buffer} =~ $regexp) {
                my ($pre, $match, $post) = ($`, $&, $');
                $line->{result} .= $pre;
                $line->{match} = $match;
                $line->{post} = $post;
            } else {
                $line->{match} = undef;
                $line->{post} = $line->{buffer};
            }
        }
        my @matchingLines = grep { defined $_->{match} } @{$self->lines};
        if ($self->verbose) {
            warn(sprintf("  %d lines match\n", scalar @matchingLines));
        }
        if (!scalar @matchingLines) {
            foreach my $line (@{$self->lines}) {
                delete $line->{match};
                delete $line->{buffer};
                $line->{result} .= $line->{post};
                delete $line->{post};
            }
            return 0;
        }
        $self->trimLinesAtEnd(@matchingLines);
        $self->padLines(@matchingLines) if $self->alignBefore;
        $self->appendSpaces($self->spacesBefore, @matchingLines) if $self->spacesBefore;
        foreach my $line (@matchingLines) {
            $line->{result} .= $line->{match};
            $line->{buffer} = $line->{post};
            delete $line->{match};
        }
        $self->trimLinesAtEnd(@matchingLines);
        $self->padLines(@matchingLines);
        $self->appendSpaces($self->spacesAfter, @matchingLines) if $self->spacesAfter;
        $self->trimLinesAtStart(@matchingLines);
        return 1;
    }
    sub trimLinesAtEnd {
        my ($self, @lines) = @_;
        foreach my $line (@lines) {
            $line->{result} =~ s{\s+$}{};
        }
    }
    sub trimLinesAtStart {
        my ($self, @lines) = @_;
        foreach my $line (@lines) {
            $line->{buffer} =~ s{^\s+}{};
        }
    }
    sub appendSpaces {
        my ($self, $numSpaces, @lines) = @_;
        foreach my $line (@lines) {
            $line->{result} .= ' ' x $numSpaces;
        }
    }
    sub padLines {
        my ($self, @lines) = @_;
        my $maxLength = max map { length $_->{result} } @lines;
        foreach my $line (@lines) {
            my $length = length $line->{result};
            my $numSpaces = $maxLength - $length;
            $line->{result} .= ' ' x $numSpaces;
        }
    }
    sub printLines {
        my ($self) = @_;
        foreach my $line (@{$self->lines}) {
            my $text = $line->{result} . ($line->{post} // '');
            $text =~ s{\s+$}{};
            print "$text\n";
        }
    }
};


# #!/usr/bin/env perl
# #
# # align - a utility influenced by M-x align-regexp.
# # But more powerful because it uses Perl regular expressions.
# #
# # TODO: align --debug --fixed -e '()' -e ';' doesn't work
# # gc () { git commit "$@" ; }
# # gpull () { git pull "$@" ; }
# # gpush () { git push "$@" ; }
# # gcj () { git commit-js "$@" ; }
# # gcc () { git commit-css "$@" ; }
# # gccj () { git commit-css-js "$@" ; }
# # gcjc () { git commit-js-css "$@" ; }
# # gaa () { git add --all "$@" ; }
# # gau () { git add --update "$@" ; }
# # gs () { git status "$@" ; }
# # gco () { git checkout "$@" ; }
# # gd () { git difff "$@" ; }
# # gl () { git logg "$@" ; }
# #
# # TODO: align --repeat --after ',' hangs

# use warnings;
# use strict;
# use v5.10.0;

# use open qw(:locale);
# use Encode::Locale;
# use Encode qw(decode);
# BEGIN {
#     @ARGV = map { decode('locale', $_, Encode::FB_CROAK) } @ARGV;
# }

# use Getopt::Long;
# use List::Util qw(max all min);
# use Data::Dumper qw(Dumper);
# use Text::Tabs qw(expand);

# local $Data::Dumper::Indent   = 0;
# local $Data::Dumper::Terse    = 1;
# local $Data::Dumper::Deepcopy = 1;
# local $Data::Dumper::Sortkeys = 1;
# local $Data::Dumper::Useqq    = 1;

# sub usage { print <<EOF; }
# usage:
#   align [<option> ...] <pattern> [<file> ...]
# options:
#   -b, --before             align spaces before <pattern> (default)
#   -a, --after              align spaces after <pattern>
#   -B, --no-before          do not align spaces before <pattern>
#   -A, --no-after           do not align spaces after <pattern>
#   -f, --fixed              interpret patterns as fixed strings
#   -r, --regexp             interpret patterns as perl regexps (default)
#   -i, --case-insensitive   case-insensitive pattern match
#       --case-sensitive     case-sensitive pattern match (default)
#   -e, --pattern=<pattern>  specify multiple patterns, like grep
#   -m, --max-columns=<int>  specify maximum number of column alignments
#       --repeat             repeat as many alignments as possible
# EOF
# ###############################################################################

# my $debug                = 0;
# my $patternType          = 'regexp';
# my $caseInsensitive      = 0;
# my $maxColumns           = 1;   # 0 = infinity
# my @patterns;
# my $alignBefore;
# my $alignAfter;
# my $repeat               = 0;

# Getopt::Long::Configure('bundling', 'gnu_compat', 'no_ignore_case');
# Getopt::Long::GetOptions(
#     'a|after|align-after'         => sub { $alignAfter  = 1; },
#     'b|before|align-before'       => sub { $alignBefore = 1; },
#     'A|no-after|no-align-after'   => sub { $alignAfter  = 0; },
#     'B|no-before|no-align-before' => sub { $alignBefore = 0; },
#     'debug+'                      => \$debug,
#     'e|pattern=s'                 => sub {
#         push(@patterns, {
#             alignBefore     => $alignBefore,
#             patternType     => $patternType,
#             caseInsensitive => $caseInsensitive,
#             pattern         => $_[1],
#         });
#     },
#     'r|regexp'                    => sub { $patternType = 'regexp'; },
#     'i|case-insensitive'          => \$caseInsensitive,
#     'case-sensitive'              => sub { $caseInsensitive = 0; },
#     'f|fixed'                     => sub { $patternType = 'fixed'; },
#     'repeat'                      => \$repeat,
#     'h|help'                      => sub { usage(); exit(0); },
# ) or die("Type '$0 --help' for help.\n");

# if (!defined $alignBefore && !defined $alignAfter) {
#     $alignBefore = 1;
#     $alignAfter = 0;
# } else {
#     $alignBefore //= 0;
#     $alignAfter //= 0;
# }

# if (!scalar @patterns) {
#     if (!scalar @ARGV) {
#         die("pattern must be specified.\n");
#     }
#     my $pattern = shift(@ARGV);
#     push(@patterns, {
#         alignBefore     => $alignBefore,
#         alignAfter      => $alignAfter,
#         patternType     => $patternType,
#         caseInsensitive => $caseInsensitive,
#         pattern         => $pattern
#     });
# }

# foreach my $pattern (@patterns) {
#     my $p = $pattern->{pattern};
#     if ($debug) {
#         print $p;
#     }
#     if ($pattern->{patternType} eq 'fixed') {
#         $p = quotemeta($p);
#     }
#     if ($pattern->{caseInsensitive}) {
#         $p = qr{(\s*)($p)(\s*)}i;
#     } else {
#         $p = qr{(\s*)($p)(\s*)};
#     }
#     if ($debug) {
#         say " => ", $p;
#     }
#     $pattern->{pattern} = $p;
# }

# my @lines;

# while (<>) {
#     s{\R\z}{};
#     $_ = expand($_);
#     push(@lines, {
#         text => $_,
#         filename => $ARGV,
#         lineNumber => $.,
#     });
# }

# my $cycleMatch;
# do {
#     $cycleMatch = 0;
#   pattern:
#     foreach my $pattern (@patterns) {
#         foreach my $line (@lines) {
#             if ($line->{text} =~ $pattern->{pattern}) {
#                 my ($preMatch, $spaceBefore, $match, $spaceAfter, $postMatch) =
#                     ($`, $1, $2, $3, $');
#                 $line->{matches} = 1;
#                 $line->{result} = ($line->{result} // '') . $preMatch;
#                 $line->{spaceBefore} = $spaceBefore;
#                 $line->{match}       = $match;
#                 $line->{spaceAfter}  = $spaceAfter;
#                 $line->{text}        = $postMatch;
#             } else {
#                 delete $line->{spaceBefore};
#                 delete $line->{match};
#                 delete $line->{spaceAfter};
#             }
#         }
#         my @matchingLines = grep { $_->{matches} } @lines;
#         if (!scalar @matchingLines) {
#             next pattern;
#         }
#         $cycleMatch = 1;

#         if ($pattern->{alignBefore}) {
#             my $maxColumn = 1 + max(map { length $_->{result} } @matchingLines);
#             foreach my $line (@matchingLines) {
#                 $line->{result} .= ' ' x ($maxColumn - length $line->{result});
#                 delete $line->{spaceBefore};
#             }
#         } else {
#             foreach my $line (@matchingLines) {
#                 $line->{result} .= delete $line->{spaceBefore};
#             }
#         }

#         foreach my $line (@matchingLines) {
#             $line->{result} .= delete $line->{match};
#         }

#         if ($pattern->{alignAfter}) {
#             my $maxColumn = 1 + max(map { length $_->{result} } @matchingLines);
#             foreach my $line (@matchingLines) {
#                 if (length $line->{text}) {
#                     $line->{result} .= ' ' x ($maxColumn - length $line->{result});
#                 }
#                 delete $line->{spaceAfter};
#             }
#         } else {
#             foreach my $line (@matchingLines) {
#                 $line->{result} .= delete $line->{spaceAfter};
#             }
#         }
#     }
# } while ($repeat && $cycleMatch);

# foreach my $line (@lines) {
#     print $line->{result} if defined $line->{result};
#     print $line->{text}, "\n";
# }
