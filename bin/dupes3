#!/usr/bin/env perl
use warnings;
use strict;
use open qw(locale);
use feature qw(state);

use File::Find qw();
use Digest::SHA qw();
use Scalar::Util qw(looks_like_number);
use File::Spec::Functions qw(abs2rel);
use Generator::Object;
use Getopt::Long;

our $verbose = 0;
our $dryRun = 0;

Getopt::Long::Configure(qw(gnu_compat bundling no_ignore_case));
Getopt::Long::GetOptions(
    "v|verbose+" => \$verbose,
    "n|dry-run" => \$dryRun,
) or die("unknown option\n");

STDOUT->autoflush(1);
STDERR->autoflush(1);

my $minSize = 1048576;
if (scalar @ARGV && looks_like_number($ARGV[0])) {
    $minSize = shift(@ARGV);
}

die("not enough arguments\n") if scalar @ARGV < 2;
my (@dirs) = @ARGV;

while (scalar @dirs >= 2) {
    my $dir = shift(@dirs);
    if ($verbose) {
        warn("INFO: dupes $dir @dirs\n");
    }
    dupes($dir, @dirs);
}

our %done;
our %count;

sub dupes {
    my ($dir, @otherDirs) = @_;
    my $wanted = sub {
        my @lstat = lstat($_);
        return unless scalar @lstat;
        if ($verbose && -t 2) {
            my $count = ($count{$File::Find::dir} += 1);
            progress("%s %d", $File::Find::dir, $count);
        }
        return if -d _ || !-f _ || -s _ < $minSize;
        my $rel = abs2rel($_, $dir);
        return if $done{$rel};
        my ($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size, $atime, $mtime, $ctime, $blksize, $blocks) = @lstat;
        my @otherFiles = map { "$_/$rel" } @otherDirs;
        @otherFiles = grep { -f $_ && -s $_ == $size } @otherFiles;
        return unless scalar @otherFiles;
        my @files = ($_, @otherFiles);
        my @gen = map { { filename => $_, gen => fileContentsGenerator($_) } } @files;
        my $gen = sameGroupGenerator(@gen);
        while (1) {
            my $next = $gen->next();
            if (defined $next) {
                my @filenames = map { $_->{filename} } @$next;
                my ($first, @other) = @filenames;
                next if !scalar @other;
                if ($dryRun) {
                    progress();
                    foreach my $other (@other) {
                        warn(sprintf("DRY RUN: rm $other (%d bytes)\n", $size));
                    }
                } else {
                    foreach my $other (@other) {
                        if (!unlink($other)) {
                            progress();
                            warn("WARN: rm $other: $!\n");
                        } elsif ($verbose) {
                            progress();
                            warn(sprintf("INFO: removed $other (%d bytes)\n", $size));
                        }
                    }
                }
            }
            last if $gen->exhausted();
        }
    };
    File::Find::find({ wanted => $wanted, no_chdir => 1 }, $dir);
    progress();
}

sub progress {
    state $empty = 1;
    return if !-t 2;
    return unless $verbose;
    my ($format, @params) = @_;
    if (!defined $format) {
        return if $empty;
        print STDERR ("\r\e[K");
        $empty = 1;
    } else {
        printf STDERR ("\r$format", @params);
        print STDERR ("\e[K");
        $empty = 0;
    }
}

sub sum {
    my ($filename) = @_;
    my $sha = Digest::SHA->new('1');
    $sha->addfile($filename);
    return $sha->hexdigest();
}

sub sameGroupGenerator {
    my @obj = @_;
    my @group = ([@obj]);
    my $sub = sub {
        while (1) {
            my @newgroup;
            foreach my $group (@group) {
                my @done;
                my %group;
                foreach my $obj (@$group) {
                    my $gen = $obj->{gen};
                    my $next = $gen->next();
                    if ($gen->exhausted()) {
                        if (defined $gen->retval()) {
                            warn($gen->retval());
                        } else {
                            push(@done, $obj);
                        }
                    } else {
                        push(@{$group{$next}}, $obj) if defined $next;
                    }
                }
                if (scalar @done >= 2) {
                    if ($_->wantarray) {
                        $_->yield(@done);
                    } else {
                        $_->yield(\@done);
                    }
                }
                foreach my $key (keys %group) {
                    my $group = $group{$key};
                    if (scalar @$group >= 2) {
                        push(@newgroup, $group);
                    }
                }
            }
            if (!scalar @newgroup) {
                return;
            }
            @group = @newgroup;
        }
    };
    return Generator::Object->new($sub);
}

sub fileContentsGenerator {
    my ($filename) = @_;
    my $sub = sub {
        my $fh;
        open($fh, '<:raw', $filename);
        while (1) {
            my $data;
            my $result = sysread($fh, $data, 4096);
            if (!defined $result) {
                return "$filename: $!\n";
            }
            if ($result == 0) {
                return;
            }
            $_->yield($data);
        }
    };
    return Generator::Object->new($sub);
}
