#!/usr/bin/env bash
set -o errexit
set -o pipefail
set -o nounset
set -o xtrace

main () {
    command=install
    verbose=0

    while getopts 'v' OPTION ; do
        case "$OPTION" in
            v)
                verbose=$((verbose + 1))
                >&2 echo "verbose is now $verbose"
                ;;
        esac
    done
    shift $((OPTIND - 1))

    >&2 echo "arguments are now [$#] $@"

    if (( $# )) ; then
        case "$1" in
            install|check)
                command="$1"
                shift
                ;;
        esac
    fi

    >&2 echo "command is now $command"
    >&2 echo "arguments are now [$#] $@"

    add-modules

    if (( $# )) ; then
        run_all_modules=0
        for i in "$@" ; do
            requested_modules["$i"]=1
        done
    fi

    case "$command" in
        install)
            install-all-modules
            ;;
        check)
            check-all-modules
            ;;
    esac
}

install-all-modules () {
    for i in "${modules[@]}" ; do
        if module-is-requested "$i" ; then
            install-module "$i"
        fi
    done
}

check-all-modules () {
    for i in "${modules[@]}" ; do
        if module-is-requested "$i" ; then
            check-module "$i"
        fi
    done
}

install-module () {
    if module-is-installed "$1" ; then
        return 0
    fi
    local cygwin_package="${cygwin_packages[$1]}"
    local cygwin_requires="${cygwin_requires[$1]}"
    if [[ "$OSTYPE" = "cygwin" ]] && [[ "${cygwin_package}" != "" ]] ; then
        if [[ "${cygwin_requires}" != "" ]] ; then
            for i in ${cygwin_requires} ; do
                run apt-cyg install "${i}"
            done
        fi
        run apt-cyg install "${cygwin_package}"
        if ! module-is-installed "$1" ; then
            >&2 echo "Failed to install $1."
            exit 1
        fi
        return 0
    fi
    run cpan "$1"
    if ! module-is-installed "$1" ; then
        >&2 echo "Failed to install $1."
        exit 1
    fi
    return 0
}

check-module () {
    if module-is-installed "$1" ; then
        >&2 echo "$1 is installed."
    else
        >&2 echo "$1 is NOT installed."
    fi
    return 0
}

run_all_modules=1
declare -A requested_modules

die () {
    >&2 echo "$@"
    exit 1
}

run () {
    >&2 echo "[$@]"
    "$@" || die "$@"
}

declare -a modules=()
declare -A cygwin_packages
declare -A cygwin_requires

add-module () {
    local cygwin_package=''
    local OPTIND
    local OPTION
    local OPTERR
    local OPTARG
    local -a cygwin__requires=()

    while getopts 'C:' OPTION ; do
        case "$OPTION" in
            C)
                case "$OPTARG" in
                    ,*)
                        cygwin__requires+=("${OPTARG#,}")
                        ;;
                    *)
                        requested_modules["$OPTARG"]=0
                        cygwin_package="$OPTARG"
                        ;;
                esac
                ;;
        esac
    done
    shift $((OPTIND - 1))

    modules+=("$1")
    requested_modules["$1"]=0

    if [[ "$cygwin_package" != "" ]] ; then
        cygwin_packages["$1"]="$cygwin_package"
    else
        cygwin_packages["$1"]=""
    fi

    if (( "${#cygwin__requires[@]}" )) ; then
        cygwin_requires["$1"]="${cygwin__requires[*]}"
    else
        cygwin_requires["$1"]=""
    fi
}

add-modules () {
    >&2 verbose echo "add-modules has begun."

    add-module -C perl-DBI            DBI
    add-module -C perl-DBD-mysql      DBD::mysql
    add-module -C perl-DBD-SQLite     DBD::SQLite
    add-module -C perl-DateTime       DateTime
    add-module -C perl-common-sense   common::sense
    add-module -C perl-Class-Tiny     Class::Tiny
    add-module -C perl-List-MoreUtils List::MoreUtils
    add-module -C perl-Archive-Zip    Archive::Zip
    add-module -C perl-Encode-Locale  Encode::Locale
    add-module -C perl-GD \
               -C ,libgd-devel        GD
    add-module -C perl-Image-Magick   Image::Magick
    add-module -C perl-JSON           JSON
    add-module -C perl-JSON-XS        JSON::XS
    add-module -C perl-JSON-PP        JSON::PP
    add-module -C perl-LWP            LWP
    add-module -C perl-Regexp-Common  Regexp::Common
    add-module -C perl-URI            URI
    add-module -C perl-XML-LibXML     XML::LibXML
    add-module -C perl-YAML           YAML
    add-module -C perl-File-Which     File::Which
    add-module -C perl-File-Slurp     File::Slurp
    add-module -C perl-Path-Tiny      Path::Tiny
    add-module                        Glib # cygwin has package for perl 5.26; latest perl package is different version
    add-module -C perl-HTML-Parser    HTML::Parser
    add-module -C perl-HTTP-Cookies   HTTP::Cookies
    add-module -C perl-HTTP-Date      HTTP::Date
    add-module -C perl-HTML-Tagset    HTML::Tagset
    add-module -C perl-HTML-Tree      HTML::Tree
    add-module -C perl-IPC-Run        IPC::Run
    add-module -C perl-Text-CSV       Text::CSV
    add-module -C perl-Text-CSV_XS    Text::CSV_XS
    add-module -C perl-Text-Diff      Text::Diff
    add-module -C perl-Gtk2           Gtk2
    add-module -C perl-Term-ReadLine-Gnu  Term::ReadLine::Gnu
    add-module -C perl-Term-ReadLine-Perl Term::ReadLine::Perl

    add-module Carp::Always
    add-module Curses
    add-module List::Util
    add-module HTML::Entities
    add-module Moo
    add-module Moose
    add-module Expect
    add-module Time::ParseDate
    add-module Date::Parse
    add-module DateTime::Format::DateParse
    add-module PDF::API2
    add-module Sort::Naturally
    add-module String::ShellQuote
    add-module String::Unescape

    add-module Class::MethodMaker
    add-module Expect
    add-module File::MMagic
    add-module Glib
    add-module Google::ProtocolBuffers
    add-module Graphics::ColorUtils
    add-module HTML::Entities
    add-module HTML::Form
    add-module HTML::LinkChanger
    add-module HTML::LinkChanger::Absolutizer
    add-module HTML::LinkExtor
    add-module HTML::Mason
    add-module HTML::Selector::XPath
    add-module HTML::Valid::Tagset
    add-module HTTP::Cache::Transparent
    add-module HTTP::Request
    add-module HTTP::Request::Common
    add-module HTTP::Status
    add-module Image::Size
    add-module Inline::MakeMaker
    add-module IPC::Open2
    add-module Irssi
    add-module List::MoreUtils
    add-module List::Util
    add-module LWP::Simple
    add-module LWP::UserAgent
    add-module LWP::UserAgent::WithCache
    add-module Math::Trig
    add-module MP3::Info
    add-module MP3::Tag
    # add-module Net::IRC
    add-module SOAP::Lite
    add-module Spreadsheet::ParseExcel
    add-module Spreadsheet::ParseXLSX
    add-module Spreadsheet::WriteExcel
    add-module Term::ANSIColor
    add-module Term::Cap
    add-module Term::ReadPassword
    add-module Term::Size
    add-module Test::More
    add-module Text::ASCIITable
    add-module Text::FormatTable
    add-module Text::ParseWords
    add-module Text::SimpleTable
    add-module Text::Table
    add-module Text::Tabs
    add-module Text::Trim
    add-module Text::Wrap
    add-module Time::HiRes
    add-module Time::Local
    add-module Time::ParseDate
    add-module Transit::GTFS::Feed
    add-module Transit::GTFS::FeedFile
    add-module Transit::GTFS::ProgressLog
    add-module WebService::Spotify
    add-module WebService::Spotify::Util
    add-module WWW::Shorten::Bitly
    add-module WWW::Shorten::TinyURL
    add-module YAML::Any
    add-module YAML::Syck

    >&2 verbose echo "add-modules is done."
}

module-is-installed () {
    if [[ "$1" = "Term::ReadLine::"* ]] ; then
        # Term::ReadLine::{Gnu,Perl} and maybe others don't want to be
        # loaded directly but we want to be able to check whether they
        # simply exist and can be loaded.
        if perl -MTerm::ReadLine -M"$1" -e exit 2>/dev/null ; then
            return 0                # true
        else
            return 1                # false
        fi
    fi
    if perl -M"$1" -e exit 2>/dev/null ; then
        return 0                # true
    else
        return 1                # false
    fi
}

module-is-requested () {
    if (( run_all_modules )) ; then
        >&2 verbose echo "$1 is requested."
        return 0                # true
    elif (( requested_modules["$1"] )) ; then
        >&2 verbose echo "$1 is requested."
        return 0                # true
    else
        >&2 verbose echo "$1 is NOT requested."
        return 1                # false
    fi
}

verbose () {
    level=1
    if [[ "$1" =~ ^[0-9]+$ ]] ; then
        level="$1"
        shift
    fi
    if (( verbose >= level )) ; then
        "$@"
    else
        return 0
    fi
}

main "$@"
