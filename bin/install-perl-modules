#!/usr/bin/env bash
set -o errexit
set -o pipefail
set -o nounset

main () {
    command=install
    verbose=0

    while getopts 'v' OPTION ; do
        case "$OPTION" in
            v)
                verbose=$((verbose + 1))
                ;;
        esac
    done
    shift $((OPTIND - 1))

    >&2 echo "arguments are now [$#] $@"

    if (( $# )) ; then
        case "$1" in
            install|check)
                command="$1"
                shift
                ;;
        esac
    fi

    run-modules
}

install-all-modules () {
    for i in "${modules[@]}" ; do
        if module-is-requested "$i" ; then
            install-module "$i"
        fi
    done
}

check-all-modules () {
    for i in "${modules[@]}" ; do
        if module-is-requested "$i" ; then
            check-module "$i"
        fi
    done
}

install-module () {
    if module-is-installed "$1" ; then
        return 0
    fi
    local cygwin_package="${cygwin_packages[$1]}"
    local cygwin_requires="${cygwin_requires[$1]}"
    if [[ "$OSTYPE" = "cygwin" ]] && [[ "${cygwin_package}" != "" ]] ; then
        if [[ "${cygwin_requires}" != "" ]] ; then
            for i in ${cygwin_requires} ; do
                run apt-cyg install "${i}"
            done
        fi
        run apt-cyg install "${cygwin_package}"
        if ! module-is-installed "$1" ; then
            >&2 echo "Failed to install $1."
            return 1
        fi
        return 0
    fi
    run cpan "$1"
    if ! module-is-installed "$1" ; then
        >&2 echo "Failed to install $1."
        return 1
    fi
    return 0
}

check-module () {
    if module-is-installed "$1" ; then
        >&2 echo "$1 is installed."
    else
        >&2 echo "$1 is NOT installed."
    fi
    return 0
}

run_all_modules=1
declare -A requested_modules

die () {
    >&2 echo "$@"
    exit 1
}

run () {
    >&2 echo "[$@]"
    "$@" || die "$@"
}

declare -a modules=()
declare -A cygwin_packages
declare -A cygwin_requires

run-module () {
    local cygwin_package=''
    local OPTIND
    local OPTION
    local OPTERR
    local OPTARG
    local -a cygwin__requires=()
    local opt_T=''

    while getopts 'TC:' OPTION ; do
        case "$OPTION" in
            T)
                opt_T='-T'
                ;;
            C)
                case "$OPTARG" in
                    ,*)
                        cygwin__requires+=("${OPTARG#,}")
                        ;;
                    *)
                        requested_modules["$OPTARG"]=0
                        cygwin_package="$OPTARG"
                        ;;
                esac
                ;;
        esac
    done
    shift $((OPTIND - 1))

    if [[ "${command}" = "install" ]] ; then
        if [[ "$OSTYPE" = "cygwin" ]] ; then
            cygwin-run-module "$@"
        elif [[ "$OSTYPE" = "darwin"* ]] && which brew >&- ; then
            brew-run-module "$@"
        else
            >&2 echo "run-module can't do anything"
        fi
    elif [[ "${command}" = "check" ]] ; then
        if module-is-installed "$@" ; then
            echo "$@ is installed."
        else
            echo "$@ is not installed."
        fi
    fi
}

brew-run-module () {
    for i ; do
        if module-is-installed "$i" ; then
            :
        else
            cpan $opt_T "$i"
        fi
    done
}

cygwin-run-module () {
    modules+=("$1")
    requested_modules["$1"]=0

    if [[ "$cygwin_package" != "" ]] ; then
        cygwin_packages["$1"]="$cygwin_package"
    else
        cygwin_packages["$1"]=""
    fi

    if (( "${#cygwin__requires[@]}" )) ; then
        cygwin_requires["$1"]="${cygwin__requires[*]}"
    else
        cygwin_requires["$1"]=""
    fi
}

run-modules () {
    >&2 verbose echo "run-modules has begun."

    run-module -C perl-YAML           YAML # required for cpan utility to keep persistent settings
    run-module -C perl-YAML-LibYAML   YAML::XS
    run-module -C perl-JSON           JSON
    run-module -C perl-JSON-XS        JSON::XS
    run-module -C perl-JSON-PP        JSON::PP
    run-module -C perl-DateTime       DateTime
    run-module -C perl-common-sense   common::sense
    run-module -C perl-Class-Tiny     Class::Tiny
    run-module -C perl-List-MoreUtils List::MoreUtils
    run-module -C perl-Archive-Zip    Archive::Zip
    run-module -C perl-Encode-Locale  Encode::Locale
    run-module -C perl-LWP            LWP
    run-module -C perl-Regexp-Common  Regexp::Common
    run-module -C perl-URI            URI

    # so much requires libxml so I run it early
    if ! module-is-installed XML::LibXML ; then
        if [[ "$command" = "install" ]] ; then
            if [[ "$OSTYPE" = darwin* ]] ; then
                if ! which xmllint ; then
                    brew install libxml2
                fi
                run-module Alien::Libxml2 || true
            fi
        fi
    fi
    if [[ "$OSTYPE" = darwin* ]] ; then
        LDFLAGS="-L/usr/local/opt/libxml2/lib" \
               CPPFLAGS="-I/usr/local/opt/libxml2/include" \
               PKG_CONFIG_PATH="/usr/local/opt/libxml2/lib/pkgconfig" \
               run-module -C perl-XML-LibXML XML::LibXML || true
    else
        run-module -C perl-XML-LibXML XML::LibXML || true
    fi

    run-module -C perl-File-Which     File::Which
    run-module -C perl-File-Slurp     File::Slurp
    run-module -C perl-Path-Tiny      Path::Tiny
    run-module -C perl-HTML-Parser    HTML::Parser
    run-module -C perl-HTTP-Cookies   HTTP::Cookies
    run-module -C perl-HTTP-Date      HTTP::Date
    run-module -C perl-HTML-Tagset    HTML::Tagset
    run-module -C perl-HTML-Tree      HTML::Tree
    run-module -C perl-IPC-Run        IPC::Run
    run-module -C perl-Text-CSV       Text::CSV
    run-module -C perl-Text-CSV_XS    Text::CSV_XS
    run-module -C perl-Text-Diff      Text::Diff
    run-module -C perl-Term-ReadLine-Gnu  Term::ReadLine::Gnu
    run-module -C perl-Term-ReadLine-Perl Term::ReadLine::Perl
    run-module Carp::Always
    run-module Curses
    run-module List::Util
    run-module HTML::Entities
    run-module Moo
    run-module Expect
    run-module Time::ParseDate
    run-module Date::Parse
    run-module DateTime::Format::DateParse
    run-module Sort::Naturally
    run-module String::ShellQuote
    run-module String::Unescape
    run-module Class::MethodMaker
    run-module Expect
    run-module File::MMagic
    run-module Google::ProtocolBuffers
    run-module Graphics::ColorUtils
    run-module HTML::Entities
    run-module HTML::Form
    run-module HTML::LinkChanger
    run-module HTML::LinkChanger::Absolutizer
    run-module HTML::LinkExtor
    run-module HTML::Mason
    run-module HTML::Selector::XPath
    run-module HTML::Valid::Tagset
    run-module HTTP::Cache::Transparent
    run-module HTTP::Request
    run-module HTTP::Request::Common
    run-module HTTP::Status
    run-module Image::Size
    run-module Inline::MakeMaker
    run-module IPC::Open2
    run-module List::MoreUtils
    run-module List::Util
    run-module LWP::Simple
    run-module LWP::UserAgent
    run-module -T LWP::UserAgent::WithCache
    run-module Math::Trig
    run-module MP3::Info
    run-module MP3::Tag
    run-module SOAP::Lite
    run-module Spreadsheet::ParseExcel
    run-module Spreadsheet::ParseXLSX
    run-module Spreadsheet::WriteExcel
    run-module Term::ANSIColor
    run-module Term::Cap
    run-module Term::ReadPassword
    run-module Term::Size
    run-module Test::More
    run-module Text::ASCIITable
    run-module Text::FormatTable
    run-module Text::ParseWords
    run-module Text::SimpleTable
    run-module Text::Table
    run-module Text::Tabs
    run-module Text::Trim
    run-module Text::Wrap
    run-module Time::HiRes
    run-module Time::Local
    run-module Time::ParseDate
    run-module Transit::GTFS::Feed
    run-module Transit::GTFS::FeedFile
    run-module Transit::GTFS::ProgressLog
    run-module WebService::Spotify
    run-module WebService::Spotify::Util
    run-module WWW::Shorten::Bitly
    run-module WWW::Shorten::TinyURL
    run-module YAML::Any
    run-module YAML::Syck

    # These modules take longer to install.

    run-module PDF::API2
    run-module Moose

    if [[ "$command" = "install" ]] && ! module-is-installed GD ; then
        if [[ "$OSTYPE" = cygwin ]] ; then
            apt-cyg install libgd-devel
        fi
    fi
    run-module -C perl-GD GD || true

    run-module -C perl-DBI DBI

    if [[ "$command" = "install" ]] && ! module-is-installed DBD::mysql ; then
        if [[ "$OSTYPE" = darwin* ]] ; then
            brew install mysql-client
        fi
    fi
    run-module -C perl-DBD-mysql DBD::mysql || true

    if [[ "$command" = "install" ]] && ! module-is-installed DBD::SQLite ; then
        if [[ "$OSTYPE" = darwin* ]] ; then
            brew install sqlite
        fi
    fi
    run-module -C perl-DBD-mysql -T DBD::SQLite || true

    if [[ "$command" = "install" ]] && ! module-is-installed Image::Magick ; then
        if [[ "$OSTYPE" = darwin* ]] ; then
            brew install imagemagick
        fi
    fi
    run-module -C perl-Image-Magick Image::Magick || true

    run-module -C perl-Gtk2 Gtk2
    run-module Glib # cygwin has package for perl 5.26; latest perl package is different version

    >&2 verbose echo "run-modules is done."
}

module-is-installed () {
    if [[ "$1" = "Term::ReadLine::"* ]] ; then
        # Term::ReadLine::{Gnu,Perl} and maybe others don't want to be
        # loaded directly but we want to be able to check whether they
        # simply exist and can be loaded.
        if perl -MTerm::ReadLine -M"$1" -e exit 2>/dev/null ; then
            return 0                # true
        else
            return 1                # false
        fi
    fi
    if perl -M"$1" -e exit 2>/dev/null ; then
        return 0                # true
    else
        return 1                # false
    fi
}

module-is-requested () {
    if (( run_all_modules )) ; then
        >&2 verbose echo "$1 is requested."
        return 0                # true
    elif (( requested_modules["$1"] )) ; then
        >&2 verbose echo "$1 is requested."
        return 0                # true
    else
        >&2 verbose echo "$1 is NOT requested."
        return 1                # false
    fi
}

verbose () {
    level=1
    if [[ "$1" =~ ^[0-9]+$ ]] ; then
        level="$1"
        shift
    fi
    if (( verbose >= level )) ; then
        "$@"
    else
        return 0
    fi
}

main "$@"
