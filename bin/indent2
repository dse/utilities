#!/usr/bin/env perl
use warnings;
use strict;

use POSIX qw(dup2);
use IO::Pty;

our @pipe1 = ('sed', 's/^/STDOUT: /');
our @pipe2 = ('sed', 's/^/STDERR: /');

my $write1 = IO::Pty->new();
if (!$write1) {
    die("pty: $!");
}
my $read1 = $write1->slave();
my $pid1 = fork();
if (!defined $pid1) {
    die("fork: $!");
}
if (!$pid1) {
    $write1->make_slave_controlling_terminal();
    close($write1);
    dup2(fileno($read1), fileno(\*STDIN)); # redirect stdin from the pty
    exec(@pipe1);
}
close($read1);
# $write1->close_slave();

my $write2 = IO::Pty->new();
if (!$write2) {
    die("pty: $!");
}
my $read2 = $write2->slave();
my $pid2 = fork();
if (!defined $pid2) {
    die("fork: $!");
}
if (!$pid2) {
    $write2->make_slave_controlling_terminal();
    close($write2);
    dup2(fileno($read2), fileno(\*STDIN)); # redirect stdin from the pty
    dup2(fileno(\*STDERR), fileno(\*STDOUT));        # redirect stdout to stderr
    exec(@pipe2);
}
close($read2);
# $write2->close_slave();

dup2(fileno($write1), fileno(\*STDOUT));  # redirect stdout to the first pty
dup2(fileno($write2), fileno(\*STDERR));  # redirect stderr to the second pty
exec(@ARGV);
