#!/usr/bin/env perl
#
# guessindent - CLI indentation guessing tool.
#
# Try to guess tab width and spacing settings.
#
use warnings;
use strict;
use v5.10.0;
use utf8;

#------------------------------------------------------------------------------
use File::Basename qw(basename);
our $PROGNAME = basename($0);

#------------------------------------------------------------------------------
use open IO => qw(:locale);
use Encode::Locale;
use Encode qw(decode);
BEGIN {
    @ARGV = map { decode('locale', $_, Encode::FB_CROAK) } @ARGV;
}

#------------------------------------------------------------------------------
our $verbose = 0;
our $dryRun = 0;

#------------------------------------------------------------------------------
use Getopt::Long;
Getopt::Long::Configure('bundling', 'gnu_compat', 'no_ignore_case');
Getopt::Long::GetOptions(
    'v|verbose+' => \$verbose,
    'n|dry-run'  => \$dryRun,
    'h|help'     => sub { usage(); exit(0); },
    # ...
) or die("Type '$PROGNAME --help' for help.\n");

sub usage { print(<<"END"); }
usage:
    $PROGNAME [<option> ...] <argument> ...
options:
    -h, --help
    -n, --dry-run
    -v, --verbose
    ...
END

###############################################################################

my $guess = My::Guess::Indent->new();

my $oldARGV;
while (<>) {
    if (!defined $oldARGV || $oldARGV ne $ARGV) {
        $guess->setFilename($ARGV);
    }
    $guess->addLine($_);
} continue {
    if (eof(ARGV)) {
        $guess->eof();
    }
    $oldARGV = $ARGV;
}

$guess->analyze();

###############################################################################

package My::Guess::Indent {
    use Moo;
    INIT {
        has files       => (is => 'rw', default => sub { return []; });
        has currentFile => (is => 'rw');
        has filename    => (is => 'rw');
    }
    sub addLine {
        my ($self, $text) = @_;
        $text =~ s{\R\z}{};     # safer chomp
        if (!defined $self->currentFile) {
            $self->currentFile(My::Guess::Indent::File->new(filename => $self->filename));
            push(@{$self->files}, $self->currentFile);
        }
        $self->currentFile->addLine($text);
    }
    sub setFilename {
        my ($self, $filename) = @_;
        if (!defined $self->filename || $self->filename ne $filename) {
            $self->eof();
            $self->filename($filename);
        }
    }
    sub eof {
        my ($self) = @_;
        if (defined $self->currentFile) {
            $self->currentFile(undef);
        }
    }
    sub analyze {
        my ($self) = @_;
        foreach my $file (@{$self->files}) {
            $file->analyze();
        }
    }
};

package My::Guess::Indent::File {
    use Moo;
    INIT {
        has filename => (is => 'rw');
        has lines    => (is => 'rw', default => sub { return []; });
    }
    sub addLine {
        my ($self, $text) = @_;
        my $line = My::Guess::Indent::Line->new(text => $text, filename => $self->filename);
        push(@{$self->lines}, $line);
        $line->parse();
    }
    sub analyze {
        my ($self) = @_;
        $self->flagComments();
        my $lines           = scalar @{$self->lines};
        my $analyzableLines = scalar grep { $_->weight } @{$self->lines};

        foreach my $line (grep { $_->weight } @{$self->lines}) {
            $line->analyze();
        }

        printf("%s: %d lines; %d analyzable lines\n", $self->filename, $lines, $analyzableLines);
        foreach my $line (@{$self->lines}) {
            printf("%8g %2d %2d> %s\n", $line->weight // 0, $line->tabCount // 0, $line->spaceCount // 0, $line->text);
        }
    }
    sub flagComments {
        my ($self) = @_;
        my $isInBlockComment = 0;
        foreach my $line (@{$self->lines}) {
            if ($isInBlockComment) {
                $line->weight(0);
            }
            $line->flagComments(isInBlockComment => $isInBlockComment);
            $isInBlockComment = $line->endsInsideBlockComment;
        }
    }
};

package My::Guess::Indent::Line {
    use Moo;
    INIT {
        has text                   => (is => 'rw');
        has originalText           => (is => 'rw');
        has weight                 => (is => 'rw', default => 1);
        has endsInsideBlockComment => (is => 'rw');
        has filename               => (is => 'rw');
        has spaceCount             => (is => 'rw');
        has tabCount               => (is => 'rw');
    }
    INIT {
        import My::Guess::Indent::Util qw(:all);
    }
    sub BUILD {
        my ($self) = @_;
        if (!defined $self->originalText) {
            $self->originalText($self->text);
        }
    }
    sub cleanup {
        my ($self) = @_;
        my $text = $self->text;
        if (defined $text) {
            $text =~ s{\R\z}{};
            $self->text($text);
        }
    }
    sub parse {
        my ($self) = @_;
        $self->cleanup();
        my $text = $self->text;

        if (!defined $text) {
            $self->weight(undef);
            return;
        }

        my $LC = startLineComment($self->filename);

        if (defined $LC) {
            # remove strings in case /* or // occurs in one
            $text =~ s{"([^"\\]|\\"|\\[xu]\{.*?\}|\\.)*"}{};
            $text =~ s{'([^'\\]|\\'|\\[xu]\{.*?\}|\\.)*'}{};

            # remove line comments in case /* occurs in one
            $text =~ s{${LC}.*$}{};
        }

        # ignore and un-weigh blank lines
        if ($text !~ m{\S}) {
            $self->weight(0);
            return;
        }

        # ignore lines with no leading whitespace for indentation guessing purposes
        if ($text !~ m{^\s+}) {
            $self->weight(0);
            return;
        }

        # don't weigh lines whose leading whitespace contains ' ' then a tab
        if ($text =~ m{^(\s+)}) {
            my $leading = $1;
            if ($leading =~ m{ \t}) {
                $self->weight(0);
                return;
            }
        }
    }
    sub flagComments {
        my ($self, %args) = @_;

        my $isInBlockComment = $args{isInBlockComment};

        if (!defined $self->filename) {
            return;
        }

        my $SC = startBlockComment($self->filename);
        my $EC = endBlockComment($self->filename);
        my $LC = startLineComment($self->filename);

        $self->endsInsideBlockComment(0);

        if (!defined $SC || !defined $EC) {
            return;
        }

        my $text = $self->text;

        if (defined $LC) {
            # remove strings in case /* or // occurs in one
            $text =~ s{"([^"\\]|\\"|\\[xu]\{.*?\}|\\.)*"}{};
            $text =~ s{'([^'\\]|\\'|\\[xu]\{.*?\}|\\.)*'}{};

            # remove line comments in case /* occurs in one
            $text =~ s{${LC}.*$}{};
        }

        if ($isInBlockComment) {
            if ($text =~ s{^.*?${EC}}{}) {
                # we're out of a comment now
            } else {
                $self->endsInsideBlockComment(1);
                return;
            }
        }

        # remove /* ... */ comments on the same line
        while ($text =~ s{^.*?${SC}.*?${EC}}{}) {
            # do nothing else
        }

        # check for /* not followed by */
        if ($text =~ m{${SC}(?!.*?${EC})}) {
            $self->endsInsideBlockComment(1);
        }

        return;
    }
    sub analyze {
        my ($self) = @_;
        if (!$self->weight) {
            $self->tabCount(undef);
            $self->spaceCount(undef);
            return;
        }
        if (!defined $self->text) {
            $self->tabCount(undef);
            $self->spaceCount(undef);
            return;
        }
        if ($self->text !~ m{^(\t*)(\s*)}) {
            $self->tabCount(undef);
            $self->spaceCount(undef);
            return;
        }
        my ($tabs, $spaces) = ($1, $2);
        $self->tabCount(length $1);
        $self->spaceCount(length $2);
    }
};

package My::Guess::Indent::Util {
    use Exporter;
    use base 'Exporter';
    use vars (
        '@EXPORT_OK',
        '%EXPORT_TAGS',
    );
    BEGIN {
        @EXPORT_OK = (
            'startBlockComment',
            'endBlockComment',
            'startLineComment',
        );
        %EXPORT_TAGS = (
            'all' => [
                'startBlockComment',
                'endBlockComment',
                'startLineComment',
            ]
        );
    }
    sub startBlockComment {
        my ($filename) = @_;
        if ($filename =~ m{\.([ch]|[ch]pp|[ch]xx|[ch]\+\+|java|php|js|css|scss|cs)$}i) {
            return qr{/\*};
        }
        return;
    }
    sub endBlockComment {
        my ($filename) = @_;
        if ($filename =~ m{\.([ch]|[ch]pp|[ch]xx|[ch]\+\+|java|php|js|css|scss|cs)$}i) {
            return qr{\*/};
        }
        return;
    }
    sub startLineComment {
        my ($filename) = @_;
        if ($filename =~ m{\.([ch]|[ch]pp|[ch]xx|[ch]\+\+|java|php|js|scss|cs)$}i) {
            return qr{//};
        }
        return;
    }
};
