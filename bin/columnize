#!/usr/bin/env perl
use warnings;
use strict;
use List::Util qw(max min sum);
use Data::Dumper qw(Dumper);
use POSIX qw(floor);
use Getopt::Long;

### NOTE: lines per page doesn't work right.  Is for example:
###
###     page 1
###        a   i
###        b   j
###        c   k
###     page 2
###        d   l
###        e   m
###        f   n
###        g
###     page 3
###        h
###
### Should be:
###
###     page 1
###        a   d
###        b   e
###        c   f
###            g
###     page 2
###        h   l
###        i   m
###        j   n
###        k
###     ...

my $WIDTH = 80;
my $SEPAR = " | ";
my $CHUNKS = 0;
my $LINES_PER_PAGE = 0;

Getopt::Long::Configure(qw(gnu_getopt));
Getopt::Long::GetOptions(
    'w|width=i' => \$WIDTH,
    's|separator=s' => \$SEPAR,
    'c|chunks' => \$CHUNKS,
    'l|lines-per-page=i' => \$LINES_PER_PAGE,
    'help' => sub { help(); exit(0); }
) or die("Type '$0 --help' for help.\n");

sub help { print(<<EOF); }
columnize [-w|--width=INT]
          [-s|--separator=STR]
          [-c|--chunks]
          [-l|--lines-per-page=INT]
          [FILENAME ...]
EOF

my @lines;
while (<>) {
    s{\R\z}{};
    s{\s+$}{};
    push(@lines, $_);
}

while (scalar @lines && $lines[-1] !~ /\S/) {
    pop(@lines);
}

my @chunks = chunks();
columnize();

sub columnize {
    my $row_count;
    for ($row_count = max map { scalar @$_ } @chunks;
         $row_count <= scalar @lines;
         $row_count += 1) {
        my $width = compute($row_count);
        if ($width <= $WIDTH) {
            last;
        }
    }
    my ($columns, $widths) = generate($row_count);
    my @columns = @$columns;
    my @widths = @$widths;
    while (scalar grep { scalar @$_ } @columns) {
        my $line = "";
        foreach my $col_num (0 .. (scalar @columns - 1)) {
            my $column = $columns[$col_num];
            my $str = shift(@$column) // "";
            $line .= $SEPAR if length $line;
            $line .= sprintf("%-*s", $widths[$col_num], $str);
        }
        printf("%s\n", $line);
    }
}

sub compute {
    my $row_count = shift;
    if ($CHUNKS) {
        my $column_info = { row_count => 0, width => 0 };
        my @column_info = ($column_info);
        foreach my $chunk (@chunks) {
            my $column_new_row_count = $column_info->{row_count} +
              (scalar @$chunk ? 1 : 0) + scalar @$chunk;
            my $new_page = 0;
            if ($column_new_row_count > $row_count) {
                $column_info = { row_count => 0, width => 0 };
                push(@column_info, $column_info);
            } elsif ($LINES_PER_PAGE) {
                my $page_count = floor(($column_info->{row_count} + $LINES_PER_PAGE - 1) / $LINES_PER_PAGE);
                my $new_page_count = floor(($column_new_row_count + $LINES_PER_PAGE - 1) / $LINES_PER_PAGE);
                if ($page_count && $new_page_count > $page_count) {
                    $new_page = 1;
                }
            }
            if ($new_page) {
                my $new_page_count = floor(($column_new_row_count + $LINES_PER_PAGE - 1) / $LINES_PER_PAGE);
                $column_info->{row_count} = ($new_page_count - 1) * $LINES_PER_PAGE + scalar @$chunk;
            } else {
                $column_info->{row_count} +=
                  ($column_info->{row_count} ? 1 : 0) + scalar @$chunk;
            }
            $column_info->{width} = max($column_info->{width},
                                        map { length $_ } @$chunk);
        }
        my $separ = length($SEPAR) * (scalar @column_info - 1);
        return $separ + sum map { $_->{width} } @column_info;
    } else {
        my @widths;
        my $column_count = floor((scalar @lines + $row_count - 1) / $row_count);
        foreach my $column_idx (0 .. ($column_count - 1)) {
            my $start_row = $row_count * $column_idx;
            my $end_row = min($start_row + $row_count - 1, scalar @lines - 1);
            push(@widths, max map { length $_ } @lines[$start_row .. $end_row]);
        }
        my $separ = length($SEPAR) * (scalar @widths - 1);
        return $separ + sum @widths;
    }
}

sub generate {
    my $row_count = shift;
    if ($CHUNKS) {
        my $column = [];
        my @columns = ($column);
        foreach my $chunk (@chunks) {
            my $column_new_row_count = @$column +
              (scalar @$chunk ? 1 : 0) + scalar @$chunk;
            my $new_page = 0;
            if ($column_new_row_count > $row_count) {
                $column = [];
                push(@columns, $column);
            } elsif ($LINES_PER_PAGE) {
                my $page_count = floor((scalar @$column + $LINES_PER_PAGE - 1) / $LINES_PER_PAGE);
                my $new_page_count = floor(($column_new_row_count + $LINES_PER_PAGE - 1) / $LINES_PER_PAGE);
                if ($page_count && $new_page_count > $page_count) {
                    $new_page = 1;
                }
            }
            if ($new_page) {
                my $new_page_count = floor(($column_new_row_count + $LINES_PER_PAGE - 1) / $LINES_PER_PAGE);
                my $new_row_count = ($new_page_count - 1) * $LINES_PER_PAGE;
                while (scalar @$column < $new_row_count) {
                    push(@$column, '');
                }
            } else {
                push(@$column, '') if scalar @$column;
            }
            push(@$column, @$chunk);
        }
        my @widths = map { max map { length($_) } @$_ } @columns;
        return (\@columns, \@widths) if wantarray;
        return [\@columns, \@widths];
    } else {
        my @columns;
        my @widths;
        my $column_count = floor((scalar @lines + $row_count - 1) / $row_count);
        foreach my $column_idx (0 .. ($column_count - 1)) {
            my $start_row = $row_count * $column_idx;
            my $end_row = min($start_row + $row_count - 1, scalar @lines - 1);
            push(@columns, [@lines[$start_row .. $end_row]]);
            push(@widths, max map { length $_ } @lines[$start_row .. $end_row]);
        }
        return (\@columns, \@widths) if wantarray;
        return [\@columns, \@widths];
    }
}

sub chunks {
    my $chunk;
    my @chunks;
    foreach my $line (@lines) {
        if ($line !~ /\S/) {
            $chunk = undef;
            next;
        }
        if (!defined $chunk) {
            $chunk = [];
            push(@chunks, $chunk);
        }
        push(@$chunk, $line);
    }
    return @chunks;
}
